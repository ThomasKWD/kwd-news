<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8">
    <meta name="charset" content="utf-8">

    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">

    <title>Tachometer App Android DroidScript</title>
    
    <link rel="stylesheet" href="css/fontello.css">
    <link rel="stylesheet" href="css/cssgauge.css">
  
    <script src='file:///android_asset/app.js'></script>
	    <script src='js/droidscript.js'></script>
    
    <!--<script src="file:///android_asset/Html/jquery/jquery.min.js"></script>-->
    <script type="text/javascript" src="js/jquery-1.8.2.min.js"></script>
    <!--TODO: teste neueste jQuery Version-->
    
    <script src="js/jquery.tap.js"></script>

    <script src="js/cssgauge.js"></script>

<!-- this code is freely copyable between browser/phonegap/DroidScript -->
<!--
	
	NOTES:
	
	TODO: for this release

	- LANGUAGE - Webseiten in Englisch erstmal Links auf *verschiedene* Seiten der Website
	(sicherer als sich darauf verlassen, dass im Browser gleiche Sprache, da Google z.B. Sprache anders ermittelt...,
	außerdem in allen Ländern außer de/en evtl. Fehler)
		
		
	TODO: for next release:
	- ZOOM
	- zoom could mean don't use positionDisplays and don't shrink analog on quadratic displays
	- more direct options
	- skin minimal
	- LANDSCAPE
		- Zentrieren von box in vergößertem Wrapper
		- Zentrieren der wrapper
		- evtl. landscape displays wrapper vergrößern, wenn analog
		- zoom analog soll ratio berechnen und den angezeigten Winkel davon abhängig machen
	
	
	TODO: nach nächstem Release:

	- .skin-hud von skin-minimal trennen (nur ähnlich)
	- was tun bei sehr quadrat-nahen Bildschirmen? -> evtl. analog Tacho kleiner -> oder einige displays verbergen 
	andere nicht zu klein werden lassen (Problem tritt bei nur-digital nicht auf)
	-> Treshhold als ratio w/h einfach im Browser ausprobieren 
	- untere Ecken von displays-wrapper nicht rund und Rand außerhalb	
	 
	TODO:
	
	Infocard:
	- in 2 oder mehr Blöcke unterteilen, die bei großen Displays (Landscape oder immer) nebeneinander gestellt werden.
	  (oder von vorherein float responsive)
	
	Ideen:
	- Schnellumschaltungen "1-touch" (abschaltbar)
	- Skins: Standard, Minimal, Auto(=Tag/Nacht)
	-GPS-Warnung Balken unten auch bei GPS an mit Farben (je nach Range) 
	
	- glob Variablen oder array für sichtbarkeit von Komponenten spart zeitaufwendiges u. manchmal 
	  fehleranfälliges (wegen Dauer) abfragen über jQuery
	  besonders für das häufige Abfragen innerhal gpstool.change

	- vordefinierte Verschachtelung für displays:
		- wenn drei, die 2 kürzesten nebeneinander, das lange darunter
		- wenn vier, die beiden langen auf eine Seite??
		- wenn 2 immer untereinander	  
		- gilt für landscape ohne gauge und portrait unter gauge
		- Länge wird im Objekt bei init gespeichert, genau wie der init-string
		
	- bei Tablet Menüs (immer rechts und )immer 90% Höhe und *immer extra Fenster mit Hinweisen*
	- Tablet Menüs evtl. auch Untermenüs rechts von Hauptmenüs (grundsätzlich Platz für drei Menüs nebeneinander, bei Portrait 2)
	  - Hilfedialog zuschaltbar (abh. vo Hinweise??)- auch bei phones/portrait (hier Breite des normalen Menüs abh. von *Höhe* in Landsacpe damit nict so breit aussieht...)
	- im menu einstellbar ob max unt mittel im Hintergrund genommen werden, wenn Tacho aus (dann könnte man ggf. GPS
	  abschalten, wenn Uhr alleine sichtbar)
	  
	- BEENDEN bei Landscape möglichst immer sichtbar (einfach nach oben?)
	
	TODO: emulator: position des browsers nehmen + network
-->


    <style>
        /* #83C2FD */
        /* #DD0000 warning */
         
        * {box-sizing:border-box;font-family:Tahoma,Verdana,Univers,sans-serif;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
        }
        /* note: select/callout should be activated in input fields or longer texts
        */
        body { margin:0;padding:0;font-size:15px;color:white;background-color:black;}
        body.en :lang(de) { display:none; }
        body.de :lang(en) { display:none; }
        p,h1,h2,h3,h4 {margin:0;padding:0;color:white;}
       html { height: 100%; } body { min-height: 100%; }
        .hgchange {
        	opacity:0.0;
              }
		#hg {
    		position:fixed;
    		top:0;
    		left:0;
    		width:100%;
    		height:100%;
    		/* JS must reset me to real height */
    		background-color:#83C2FD;
    		transition:1.5s opacity ease-in;
		}
		/* for debugging and testing: */
		#ruler {
			position:fixed;
			width:0;
			height:100%;
			top:0;
			left:300px;
			border-top:1px solid red;
			border-left:1px solid blue;
			z-index:10000;
			display:none;
		}
		/* links and menus */
		a,a:hover,a:focus,a:active,a:visited {
	         -webkit-tap-highlight-color: rgba(255,255,255,0);
		}   
        .ext-btn,
        .btn {
            display:block;
            color:white !important;
            font-size:130%;
            font-weight:bold;
            background-color:#888;
            padding:5px;
            margin:1em;
            border:4px solid #f0f0f0;
            border-radius:15px;
            box-shadow:3px 3px 10px #ddd inset,-3px -3px 7px #555 inset;
            text-decoration:none;
            text-align:center;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
        }
        /* want colors of KWD Logo */
        .ext-btn { 
        	background-color:#83C2FD;
        	border-color:#DF3F2E;
            box-shadow:3px 3px 10px #eee inset,-3px -3px 7px #444 inset;
        }
        /*  switcher must not have .btn
            can have class "switched-on" to determine state
        */
        a.switcher,
        a.switcher:link,
        a.switcher:visited,
        a.switcher:hover,
        a.switcher:focus,
        a.switcher:active {
            display:block;
            color:white;
            padding:1em 1em 1em 1em;
            /*padding:1em 1em 1em 3em;
             text-indent:-1.5em;*/
            margin:0;
            border-top:1px solid white;
            text-decoration:none;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
        }
       
        .lastswitcher {
            border-bottom:1px solid white;
        }
        .fa {
            color:#dd0000;
            display:inline-block;
            width:40px;
            padding-right:20px;
        }
        .switched-on .fa {
			color :#00dd00;
		}
		.menuitem .fa
		{
            color:#FFFFFF;
        }
		.mirror {
			transform:scale(-1,1);
            padding-right:0;
            padding-left:1em;
            text-align:right;
		}
		.icon-zoom-out {
			font-size:65%;
		}
        
		/* marks elements to be changed when no-gps
		 */
		.gps {
		}
		.no-gps {
			color:#dd0000 !important;
		}
        /* some properties are set by JS */
        #digital-on-analog {
            position:absolute;
            font-size:40px;
            font-weight:bold;
            text-align:center;
            color:white;
            line-height:1em;
            background-color:#000000;
            letter-spacing:0;
            border-top:1px solid #ddd;
        }

        #info-on-analog {
            position:absolute;
            color:white;
            line-height:1em;
            text-align:center;
            font-weight:bold;
        }
        .gps-warning {
        	color:#DD0000;
        }
        .gps-warning-text {
        	font-size:1.75em;
        	line-height:1em;
        }
        /* text inside #digital-on-analog shield */
        #dona-text {
            position:absolute;
            letter-spacing:0;                      
        }
/* TODO: weg schmeißen */
        .display-frame {
            position:relative;
            display:block;
            width:auto;
            height:auto;
            margin:10px;
            padding:20px 10px 20px 10px;
            font-size:150px;
            font-weight:bold;
            line-height:1em;
            text-align:center;
            overflow:hidden;
            border:1px solid white;
            white-space:nowrap;
            letter-spacing:0;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
        }
        
        /* for object-driven layout: */
       /* ! no padding-bottom since font height leads to space anyway */ 
       .display-box {
			position:relative;
			overflow:hidden;
            font-size:150px;
            line-height:1em;
            font-weight:bold;
			padding:5px 15px 0 15px;
			white-space:nowrap;
			text-align:center;
			top:0;
			left:0;  
			border-top:1px solid #ddd;       	
       }
      .first-display {
       		border-top-color:transparent;
       		margin-top:0;
       }
		.positioner {
			position:absolute;
		}
		#displays-positioner {
			/*outline: 1px solid green;*/
		}
		#digitalspeed-positioner {
			/*outline: 1px solid yellow;*/ 
		}
		/* not yet defined!: */
		#analogspeed-positioner {
			/*outline: 1px solid red;*/
 		}
 		#cssgauge-wrapper {
 			/*outline:1px solid orange;*/
 		}
        #displays-wrapper {
        	margin-top:10px;
        }
        #tacho-container {
        	position:absolute;
        }
        #display-container,
		#digitalspeed-wrapper {
			position:relative;
		}
		#tacho-container {
			/*outline:1px solid red;*/
		}        
        #seconds-text {
        	font-size:50%;
        }
        .halfsize {
        	background-color: #000000;
        }
        #maxspeed {
        	float:right;
        }
        #averagespeed {
			float:left; 	
        }
        .speed {
            line-height:1.25em;
        }
        /* kmh wird jetzt unabhängig gesetzt, da es bei analog die Anzeige
        von canvgauge verdeckt.
        wenn digital, soll es allerdings innerhalb positioniert werden.
        Alternative: zwei verschiedene 
        
        TODO: Schriftgrößen aller digitalen Anzeigen inkl. .unitlabel
            in Funktion gleichwertig verarbeiten!
            
        */
        .unitlabel {
            position:absolute;
            color:white;
            line-height:2rem;
            text-align:center;
            font-weight:normal;
            padding:10px;
            font-size:0.9rem;
            right:0;
            bottom:0;        
        }
        #gauge {
            /*
                  transform:scale(-1,1);
          -moz-transform:scaleX(-1);
          -webkit-transform: scaleX(-1);
          */
        }
        #title {
            position:relative;
            bottom:1em;
            padding:1em;
        }
        #logo img {
            width:100%;
            margin-left:-7px;
            margin-bottom:15px;
        }
        #title p{
            margin-bottom:5px;
        }
        /* for current control funcs. all dialogs must be visible! */
        .dialog,
		#displays-wrapper,
		#digitalspeed-wrapper {
			margin:10px;
            color:white;
            background-image:-webkit-linear-gradient(rgba(100,100,100,0.95) 5%, rgba(0,0,0,0.95) 40%);
            background-image:linear-gradient(rgba(100,100,100,0.95) 5%, rgba(0,0,0,0.95) 40%);
            /*box-shadow: 5px 5px 10px #000 inset,5px 5px 20px #000;*/
            box-shadow: 5px 5px 10px #000 inset;
            border:10px solid #ddd;
            border-radius:3em;
            font-size:1em;
        }
        #displays-wrapper {
        	position: relative;
        }
		.dialog {
			display:none;
			position:absolute;
	        width:90%;
	        max-width:30em;
			top:10px;
			box-shadow: 5px 5px 20px #000;
		 }
        .dialog p,
        .dialog h1,
        .dialog h2,
        .dialog h3 {
            margin:1em;
        }
        #menu {
            margin: 1em auto;
            text-align:center;
            display:none;
        }
        #warningdialog {
            color:white;
            border-color:#CC0000;
        }
        #warningdialog h1 {
            color:red;
            text-align:center;
        }
        #warningdialog p {
        	font-weight:bold;
        }
        #yesnodialog {
            text-align:center;
            top:25%;
        }
        #yesnodialog * {
            font-size:1.2em;
        }        
        #splashscreen {
        	display:table;
            background-color: #83C2FD;
            position:absolute;
            top:0;
            left:0;
            width:100%;
            height:100%;
        	padding:20px;
        }
        #splashscreen p {
        	display:table-cell;
        	vertical-align:middle;
            font-weight:bold;
            text-align:center;
        }
        #splashscreen img {
            width:100%;
            max-width:360px;
        }
        #wait {
            width:200px;
            height:2em;
            margin:auto;
        }
        #infocard {
            position:absolute;
            top:0;
            width:100%;
            min-height:100%;
            overflow:scroll;
            background-color:white;
            color:black;
            padding:25px;
            display:none;
        }
        #infocard * {
            color:black;
        }
        #infocard p,
        #infocard h1,
        #infocard h2,
        #infocard h3 {
            margin-bottom: 0.7em;
        }
        #infocard h3{
            font-size:1em;
        }
        #infocard a {
            font-weight:bold;
            color:  #40a1fc;
        }
        /* neg right padding due to css of .fa : */
        #menubutton {
            position:absolute;
            top:0;
            right:0;
            font-size:2em;
            padding:0.5em 0em 1em 1em;
            margin: 0 -0.25em 0 0;
        }
        #gpswarning {
            position:absolute;
            top:0;
            left:0;
            font-size:15px;
            font-weight:bold;
            color:#ff2222;
            color:white;
            padding:0.3em;
            background-color: rgba(0,0,0,0.6);
            border-right:3px solid #aa0000;
            border-bottom:3px solid #aa0000;
            border-bottom-right-radius: 10px;
        }
        .toastmessage {
		    width:80%;
		    height:auto;
		    position:fixed;
		    left:50%;
		    margin-left:-40%;
		    bottom:10px;
		    background-color: #383838;
		    color: #F0F0F0;
		    font-family: Calibri,sans-serif;
		    font-size: 20px;
		    padding:10px;
		    text-align:center;
		    border-radius: 2px;
		    -webkit-box-shadow: 0px 0px 24px -1px rgba(56, 56, 56, 1);
		    -moz-box-shadow: 0px 0px 24px -1px rgba(56, 56, 56, 1);
		    box-shadow: 0px 0px 24px -1px rgba(56, 56, 56, 1);
		    display:none;
		}
		
		/* 
		für Skins addClass mit verschachtelten Klassen,
		*/
		
		/* skin-minimal */  
		/* TODO: skin class only in wrapper
		 * TODO: .g-pointer shorter in .skin-minimal
		 */
		.gauge.skin-minimal {
			background-image: none;
			border-color:black;
		}
		.skin-minimal .g-center {
			background-color:black;
		}
		.skin-minimal .g-pointer {
			border-bottom-width: 130px;
		}
		.gauge.skin-minimal .g-minor,
		.gauge.skin-minimal .g-majortick {
			background-color:white;
		}
		.display-box.skin-minimal {
			border-color:transparent;
			background-color:black;
		}
		#digital-on-analog.skin-minimal {
			border-top-color: black;
		}
		#digitalspeed-wrapper.skin-minimal,
		#displays-wrapper.skin-minimal {
			background-image:none;
			background-color:black;
			border-color:black;
			box-shadow:none;
			border-radius:0;
		}
		/*
		TODO: Unterscheidung .hud-able .hud (letztere wird erst hinzugefügt, wenn hud aktiviert)
		*/
    </style>
</head>

<body onload="app.Start()">
<!-- start html -->
<div id="hg"></div>

<div id="display-container">
    <div id="tacho-container">
  
        <div id="cssgauge-wrapper"> <!--flexible size planned-->
			<div id="cssgauge" class="gauge skin">
				<div class="g-scale"></div>
					<div id="g-pointer" class="g-pointer g-item"></div>
					<!-- change order  when testing finished -->
					<div class="g-center g-item"></div>
	            <div id="digital-on-analog" class="hud skin"><div id="dona-text" class="speed gps">0000</div></div>
	            <div id="info-on-analog"><div class="units-kmh gps-no-warning">kmh/h</div><div class="gps-warning"><span class="gps-warning-text">GPS</span></div></div>
			</div>
		</div>
        <div id="speedstats" class="2-in-a-row">
            <div id="averagespeed" class="display-frame hud halfsize test"><span id="averagespeedtext" class="display-text gps">00000</span><div id="averagespeedlabel" class="unitlabel">&#216;</div></div>
            <div id="maxspeed" class="display-frame hud halfsize test"><span id="maxspeedtext" class="display-text gps">00000</span><div id="maxspeedlabel" class="unitlabel">max</div></div>
        </div>

		<!-- möglicherweise ungünstig, dies im tachocontainer zu haben-->
		<div id="digitalspeed-positioner" class="positioner">
			<div id="digitalspeed-wrapper" class="skin"><div id="digitalspeed" class="hud skin display-box"><span class="speed display-text gps">0000</span><div id="kmh-digital" class="unitlabel autofade">km/h</div></div></div>
		</div>
		
	</div><!--tacho-container-->

	<div id="displays-positioner" class="positioner">
    
    <div id="displays-wrapper" class="skin">    	
	    <div id="time" class="hud display-box skin"><span id="time-text-wrapper" class="display-text"><span id="time-text">00:00</span><span id="seconds-text">:00</span></span></div>
	    <div id="geoaltitude" class="hud display-box skin"><span id="altitudetext" class="display-text gps">00000</span><div id="m-alt" class="unitlabel autofade">m</div> </div>
		<div id="geolocation" class="hud switchlocformat display-box skin"><span id="positiontext" class="display-text gps">00°00'00.0"N<br />00°00'00.0"E</span></div>
    </div>
   </div>
	
</div>
<!--        <div id="geobearing" class="hud display-frame"><span id="bearingtext skin" class="display-text gps">000°</span><div id="bearinginfo" class="unitlabel">Sensor</div></div>
        <div id="geoaccuracy" class="hud display-frame"><span id="accuracytext skin" class="display-text gps">0000</span><div id="accuracyinfo" class="unitlabel">m</div></div>
-->

    <div id="title" class="autofade">
        
	  <p id="no-gauges"><a class="btn" href="#settings"><span lang="en">Add meters</span><span lang="de">Anzeigen zuschalten</span></a></p>
	  
  	</div>

    <div id="menu">
        <a class="btn" href="#info">Info</a>
        <a class="btn" href="#settings">Einstellungen / Settings</a>
    </div>
    
    <div id="infocard" class="card">
        <h2><span lang="de">Viel Spaß mit unserer Tacho- und GPS-App!</span><span lang="en">Welcome to this Speedometer and GPS Tool</span></h2>
		<p>by</p>
		<a id="logo" href="#"><img src="res/kwd-4-title.png" /></a>
		<p lang="de">Dies ist ein <strong>GPS</strong>-Tachometer mit Höhen-, Positions- und Zeitanzeige für Reise und Freizeit.</p>
		<p lang="en">Use this GPS speedometer with altitude, geolocation and current time, especially when you are not driving
			 a car but going by bicyle, by train, by boat or even by airplane!</p>
	  	
	    <p lang="de">Die aktuelle GPS-Position <!--oder Ihre Richtung --> schnell anzuzeigen ist in der freien Natur nicht nur interessant sondern z.B. auch im
        Notfall eine wichtige Info für Rettungskräfte. Es kann wahlweise der dezimale Wert angezeigt werden.</p>
        <p lang="en">Sometimes it is useful or even essential to display the current geoloation quickly
          - even without a network connection -  	e.g. in an emergency.</p>
        
        <p lang="de"><b>Die Genauigkeit</b> der Höhenangabe sollte nicht überschätzt werden.
        Sie liegt etwa im gleichen Bereich wie die der Position, wo die Ungenauigkeit
        selbst bei guten Empfang meist zwischen 3 und 20 Metern schwankt (bei schlechtem Empfang bis über 100 Meter).
        Ähnliches gilt für die Geschwindigkeit bei sehr geringen Werten.</p>
        
        <p lang="en">Note that the <b>accuracy</b> seems very low when observing the height value since it will be the same as 
        	the accuracy of location. While you expect the location to differ for some meters, it looks odd in terms of height 
        	when there is in error of 3m or even 50 m (depending on GPS signal). This also applies to very low speed values.</p> 
        	 
        
        <p lang="de">Ihr Gerät benötigt einen <b>GPS-Sensor</b> für die Geschwindigkeit. Netzempfang ist jedoch nicht nötig.
        	Die App kann auch im "Flugmodus" laufen.
        	Bitte beachten Sie, dass Sie  eventuell erst GPS (meist "Standort > Hohe Genauigkeit" genannt) in den Einstellungen
        Ihres Gerätes aktivieren müssen.</p>
        <p lang="en">Your device must have a <b>GPS-sensor</b> enabled to display speed (see under 'Location' in the device's
        	settings). You don't need a network connection and can also use the app in "flight mode". 
        
      	<p lang="de"> <b>Die HUD-Funktion</b>
        ("Head-Up-Display") erlaubt es, das Gerät mit gespiegelter Anzeige vor die Scheibe eines Fahrzeugs zu legen.</p>
        <p lang="en">With <b>"HUD" (head up display)</b> turned on you can put your device in front of mirroring glass (of an vehicle) to read the 
        	reflected displays. Note that the brightness of your device ist not high enough for daylight use in most cases.</p>
        
<!--
	        <p lang="de">Die Einstellung "<b>Direktauswahl</b>" erlaubt die Änderung einiger Einstellungen, wenn Sie einfach auf die Anzeigen tippen.
        	Diese Funktion kann abgeschaltet werden.</p>
        <p lang="en">The option "Direct Config" means you can change some settings by tapping the gauges and values. You can turn of this option in the settings menu.</p>
-->    
        <p lang="de">Standortdaten werden nicht weiter verarbeitet.</p>
        
        <p>KWD Tacho Version 1.10 &copy; 2015 <a class="ext-link" href="http://kuehne-webdienste.de/">KUEHNE-Webdienste.de</a></p>
        <p><a class="ext-link" href="http://kuehne-webdienste.de/index.php?article_id=47">Datenschutzerklärung / Privacy policy</a></p>
        <p><a class="ext-link" href="http://kuehne-webdienste.de/index.php?article_id=49">Lizenzen / Licenses</a></p>
        
        <p lang="de">Diese App verzichtet auf Werbe-Einblendungen und ist dennoch kostenlos.
        Falls Ihnen die App gefällt, können Sie ihre Entwicklung voran treiben,
        indem Sie einen kleinen Betrag spenden. Vielen Dank!
        
        <a href="http://kuehne-webdienste.de/index.php?article_id=50" class="ext-btn ext-link" lang="de">Spenden</a>
        
        </p>

    </div>

  <div id="warningdialog" class="dialog">
    <h1 lang="de">Warnung!</h1>
    <h1 lang="en">Warning!</h1>
    
    <p  lang="de">Verwendung auf eigene Gefahr!</p>
    <p  lang="en">Use this app at your own risk!</p>
    
    <p lang="en">Opening or controlling the app while driving or using a machine is dangerous! Start this app before you start driving or working!</p>
    	<p lang="de">Bedienen Sie diese App nicht,
      während Sie ein Fahrzeug oder eine Maschine steuern! Starten Sie die App vor Beginn der Fahrt/Tätigkeit!</p>
      
    <p lang="en">The display timeout of your device is disabled. Don't let the device unattended!</p>
    <p lang="de"> Der Anzeige-Timeout Ihres Gerätes ist deaktiviert.
      Lassen Sie die App nicht unbeaufsichtigt laufen!</p>
      
	<p><a href="#warningcont" class="btn"><span lang="de">Weiter</span><span lang="en">Proceed</span></a></p>
  </div>

    <div id="settingsdialog" class="dialog">
        <h3 lang="de">Auswahl</h3>
        <h3 lang="en">Options</h3>

      <a id="tachoswitch" class="switcher switched-on" href="#"><span class="fa icon-gauge"></span><span lang="de">Tachometer</span><span lang="en">Speedometer</span></a>
	  <a id="switchtime" class="switcher switched-on" href="#"><span class="fa icon-clock"></span><span lang="de">Uhrzeit</span><span lang="en">Time</span></a>
	  <a id="switchaltitude" class="switcher switched-on" href="#"><span class="fa icon-zoom-out icon-android-landscape-512px"></span><span lang="en">Altitude above sea level</span><span lang="de">Höhe über NN</span></a>
	  <a id="switchposition" class="switcher switched-on" href="#"><span class="fa icon-location"></span><span lang="en">Geo-location</span><span lang="de">Position</span></a>
	  <a id="switchhudsettings" class="switcher" href="#"><span class="fa icon-sort-numeric mirror"></span>HUD</a>
      <a id="moresettings" class="switcher menuitem" href="#"><span class="fa icon-cog"></span><span lang="en">Settings ...</span><span lang="de">Einstellungen ...</span></a>
	  <a id="showinfo" class="switcher menuitem" href="#"><span class="fa icon-info-circled"></span>Info ...</a>
	  <!--<a id="switchbackkey" class="switcher switched-on" href="#"><span class="fa icon-ok"></span> Beenden mit Zurück-Taste</a>-->
	  

        <!--<a class="btn" href="#info">Info</a>-->
        <a class="btn" href="#exit"><span lang="en">EXIT app</span><span lang="de">App BEENDEN</span></a>
        <!--<a class="btn" href="#cancel">Abbrechen</a>-->
    </div>
    
    <div id="tachosettingsdialog" class="dialog">
        <h3><span lang="en">Speedometer</span><span lang="de">Tachometer</span></h3>

	      <a id="digitalanalog" class="switcher switched-on radio" href="#"><span class="fa icon-gauge-2"></span>Digital + Analog</a>
	      <a id="digital" class="switcher radio" href="#"><span class="fa icon-sort-numeric"></span><span lang="de">Nur </span>Digital<span lang="en"> only</span></a>
		  <a id="analog" class="switcher radio" href="#"><span class="fa icon-gauge"></span><span lang="de">Nur </span>Analog<span lang="en"> only</span></a>        
	       <a id="switchautorange" class="switcher menuitem" href="#"><span class="fa icon-gauge-2"></span><span lang="de">Wertebereich zurücksetzen</span><span lang="en">Reset speedometer range</span></a>	  
		  <!--
		  	<a id="maxsettings" class="switcher menuitem" href="#"><span class="fa icon-upload"></span>Höchstgeschwindigkeit</a>
		  <a id="averagesettings" class="switcher menuitem" href="#"><span class="fa icon-right"></span>Mittlere Geschwindigkeit</a>
		  -->
		  <!--<a id="alarmsettings" class="switcher menuitem" href="#"><span class="fa icon-bell-alt"></span>Geschwindigkeitsalarm</a>-->
		  <!--
		  	TODO: implement later, when auto-background-management is not enough
		  	<a id="backgroundsettings" class="switcher swithhed-on" href="#"><span class="fa icon-chart-area"></span>Hintergrundmessung</a>
		  -->
    </div>

    <div id="moresettingsdialog" class="dialog">
        <h3><span lang="en">Settings</span><span lang="de">Einstellungen</span></h3>

	    <a id="tachosettings" class="switcher menuitem" href="#"><span class="fa icon-gauge"></span><span lang="de">Tachometer</span><span lang="en">Speedometer</span> ...</a>
       <a id="switchwarning" class="switcher switched-on" href="#"><span class="fa icon-info-circled"></span><span lang="de">Hinweise anzeigen</span><span lang="en">Show notes on functions</span></a>
	    <a id="switchredwarning" class="switcher switched-on" href="#"><span class="fa icon-attention"></span><span lang="de">Warnungen anzeigen</span><span lang="en">Show warnings</span></a>
	    <a id="setlanguage" class="switcher menuitem" href="#"><span class="fa icon-globe"></span><span lang="de">Sprache: DEUTSCH</span><span lang="en">Language: ENGLISH</span></a>
    </div>        
    
    <!--<div id="menubutton"><span class="fa fa-ellipsis-v autofade"></span></div>-->
    
  <div id="gpswarning" class="gps-warning"><small><span lang="de">kein</span><span lang="en">no</span> </small>GPS</div>
  
    <div id="yesnodialog" class="dialog">
    <p> test </p>
    <a class="btn" id="yes" href="#">JA</a>
    <a class="btn" id="no" href="#">Nein</a>
    </div>

    <div id="splashscreen" class="screencard">
    	<p>
         <img src="res/kwd-4-title.png" />
    	</p>
    </div>
    
    <div class="toastmessage">Das ist ein Popup</div>
    
    <div id="ruler" class="ruler"></div>
    
	<script type="text/javascript">
	/* start javascript */

// class for global vars
function KwdTachoApp() {
	// public members
	this.language = 'en';
	
	this.storage = {
		language : 'tacholanguage'	
	};
}

kta = new KwdTachoApp();

// Konstanten
const storage_settings = 'kwd_tacho_settings';
const storage_tachorange = 'tachorange'; 
const storage_tachocurrentmax = 'tachocurrentmax'; // meint Höchstgeschwindigkeit
const storage_tachoaverage = 'tachoaveragegroups'; 
var tacho_defaultrange = 200;
var layout_gauges = 0; // counts number of displayed components (for layout and messages)
var clock_visible = false; // to check if Geoloaction can be paused
var clock_interval = null; // will be cleared if clock hidden (for performance)
var gpswarning_blinkinterval = null; 
var gpswarning_timeout = null;
var gpswarning_active = false; // saves state of warning (performance)
var cssgauge_visible = true; // will be set/unset by setTachoLayout  (performance)

// recognize browser
// ask var app_browsermode
var app_browsermode = false; 
 
 

/* set language by adding/removing classes
 * lang: auto|en|de
 * 
 */
function setLanguage(lang) {

	app.Debug('lang loaded: '+lang);
	if(!lang || lang=='auto') {
		lang = (app.GetLanguageCode()).toLowerCase(); // ! overwrite parameter value
		app.Debug('lang sys: '+lang);	
	    if (lang=='de' || lang=='at' || lang=='li') kta.language = 'de'; // ! default language: en
	    else lang = en;
	}
	$('body').removeClass('en'); // works because multiple addClass do not add more classes :-)
	$('body').removeClass('de'); // works because multiple addClass do not add more classes :-)
	$('body').addClass(lang);
	
	kta.language = lang; 
}


/* gibt eine message aus
    - kapselt app.ShowPopup, um Layout und Zusatzfunktionen steuern zu können
    (z.B. stapeln von Nachrichten ähnlich log)
*/
function toastMessage(msg) {
    app.ShowPopup(msg,'bottom');
}
/* shows message depending on language
 * - first msg: in default language
 * - second msg (optionl): in second language (now just german)
 * - TODO: make sure not called before app object 'kta' is set
 * - TODO: for more than 2 languages use array or html-texts with ids which are read by jQuery
 */
function showHint (msg,msg_de) {
	if(displayHints) {
		if (msg_de && kta.language=='de') toastMessage(msg_de);
		else toastMessage(msg);
	}
}

/* starts gps sensor 
 * - checks if clock is the only display, then don't start + even stop when already running
 * TODO: useful to wait until warning at app start is gone??
 */
var gps_running = false; // prevent loc.Start() if running OR loc.Stop() if already stopped
function startGps() {
	if (typeof loc != 'undefined') {
		var clockonly = (layout_gauges==1 && clock_visible) ? true : false; // TODO could use value from displays list
		
		if (!clockonly && !gps_running) {
			loc.Start();
			gps_running = true;
		} 
		else if (clockonly) {
			stopGps();
		} 
	}
}
/* stops gps sensor
 * - prevents multiple send stop command
 */
function stopGps() {
	if (gps_running && (typeof loc != 'undefined')) loc.Stop();
	gps_running = false;
}

var gps_blinking = false;
function gpsBlink() {
	var color = (gps_blinking) ? '#dd0000' : 'black';
	$('.gps-warning').css('color',color);		
	gps_blinking = !gps_blinking;
}
/* sets colors and warning text
 * - called by timeout or directly
 */
function setGpsWarning() {
	if(!gpswarning_active) {
	    $("#gpswarning,.gps-warning").show();
	    $('.gps-no-warning').hide();
		$('.gps').addClass('no-gps');
		gpswarning_blinkinterval = setInterval(gpsBlink,500);
		gpswarning_active = true;
	}	
}
/* removes colors and warning text
 * - usually called only directly
 * - resets the timeout 
 */
function clearGpsWarning() {
	if(gpswarning_active) {
		$("#gpswarning,.gps-warning").hide();
	    $('.gps-no-warning').show();
		$('.gps').removeClass('no-gps'); // check if without . (dot)	
		if(gpswarning_blinkinterval!==null) clearTimeout(gpswarning_blinkinterval);
		gpswarning_active = false;
	}
	if(gpswarning_timeout!==null) clearTimeout(gpswarning_timeout);
	gpswarning_timeout = setTimeout(setGpsWarning,6000); // 6s is a matter of fealing :-)
}

//var previous_time = 0; // save time for check (for performance)
var previous_minutes = -1;

/* refresh display of clock
 * - called only as interval callback
 * - disabled when clock hidden (so you don't have to check this here)
 * TODO: check whether minutes/hours have changed before calling jQuery  
 */
function changeTime() {
	
    var date = new Date();
    
    var s = date.getSeconds();
    s = ":"+((s < 10) ? "0" + s : s);
    $('#seconds-text').text(s);

    // minutes and hours are only formatted + displayed when changed:
    var m = date.getMinutes();
    if(m!=previous_minutes) {
	    previous_minutes = m;	    
	    m = ":"+((m < 10) ? "0" + m : m);
   	    var h = date.getHours();
	    h = ((h < 10) ? "0" + h : h);
	    $('#time-text').text(h+m);
    }
    
    // this prevents warning when clock is used alone
    if (layout_gauges==1) clearGpsWarning();
} 
function startClock() {
	previous_minutes = -1; // to ensure update on restart
	clock_interval = setInterval(changeTime,1000);
	clock_visible = true;
}
function stopClock() {
	if (clock_interval !== null) clearInterval(clock_interval);
	clock_visible = false;
}

function OnConfig() {
    //ATTENTION!: don't check screen rotation result here, 
    // since width and height are still old values in WebView!
    // see $(window.resize(...)
}

//Called when application is paused.
function OnPause() 
{ 
    if (typeof settings !== 'undefined') settings.save();    
    app.PreventScreenLock(false);
	app.SetScreenMode('Normal');
    // --> TODO: ein flag setzen, so dass gpstool.change darauf reagieren und z.B. nur die wichtigsten Sachen machen
    // kann, z.B. nur die Werte weiter verarbeiten, die die für die Statistik erforderlich sind.
    if (typeof gpstool !== 'undefined') gpstool.saveAverage();
    
    stopGps(); // solange keine Hinterhrundwerte für max/mittel  
}
 
// TODO: check what it does when inside menu?
// --> the double check should prevent fade
function OnResume() 
{ 
	app.Debug("on resume");
    app.PreventScreenLock(true);
    
    startGps(); // check if error when start twice!!!
    if (typeof gpstool !== undefined) 
    	if (gpstool.isHud())
    		app.SetScreenMode('Full');
    resetHud();
}

// back button hides open dialogs or screen modes like hud
function OnBack()
{
    if (app_browsermode) app.Debug('OnBack'); // why cannot see this msg??
    
	// just check if there is any open menu
	// otherwise show main menu
	if(!menustack.current()) menustack.push('settingsdialog');
	else {
		menustack.pop(); // you can read the popped element and react!
	    // no gauges warning now with *counter* 
	}
	if(menustack.current()!==false) resetMenuFade();
	resetHud(); 
	// TODO: irgendwie scheint das resetHud erst bei Klick *im* Hauptmenü zu reagieren
}

// my own app.Exit wrapper, app.Exit() must not exist more than once!
// (so i control things much better!!)
function Quit() {
    OnPause();  // nach neuesten Tests nicht automatisch
    app.Exit();
}

function confirmYesNo(str) {
    $('#yesnodialog p').text(str);
    $('#yesnodialog').show();
}

/* hardware menu button
*/
function OnMenu( name )
{                
    menustack.clear();
    OnBack(); // TODO: stack löschen und wieder bei Hauptmenü anfangen!
}



//Called when we get a change in location.  // TODO: direkt set???
function loc_OnChange( data ) 
{ 
    gpstool.change(data);
} 

/* TODO: better receive gauge as var instead of using the global var
*/
// class
function GpsTools () {
    //private:
    var speed =0.0;
    var lastspeed = 0.0;
    var dspeed = 0.0;
    var step = 0.0;
    var stepcount = 0;
    var lat = 0;
    var lon = 0;
    var locformat = true; // if true format in ° ' ", otherwise float val
    var alt = 0;
    var hud = false;
    var that=this;
    var maxspeed = 0; 
    var tachorange = 10;
    var dochangetachorange = false;
    var speedtest = 0;
    // TODO: a class from this would be nicer
    // TODO: make SIMPLE calculation by saving just the SUM and the COUNT
    // TOOD: by this make sure there will be no +e form 
    var average_count = 0; // current count of all older groups
    var average_sum = 0;   // current sum of all older groups
    var average_grouplist = new Array();
    
    var average_itemcount = 0;
    var average_list = new Array();
    var average_groupsize = 2;
    var average_treshhold = 5400;
 
    function ConvertDDToDMS(D, lng){
        return {
            dir : D<0?lng?'W':'S':lng?'E':'N',
            deg : 0|(D<0?D=-D:D),
            min : 0|D%1*60,
            sec :(0|D*60%1*6000)/100
        };
    }

    function refreshLocDisplay() {
        if(locformat) {                    
            var lf = ConvertDDToDMS(lat,false);
            //        lattest = parseInt(lf['deg']) + parseInt(lf['min']) /60 + parseInt(lf['sec']) / 3600;
            var tempstr = lf['deg']+'°'+lf['min']+"'"+(Math.round(lf['sec']*10)/10).toFixed(1)+'"'+lf['dir']+'<br />';
            var lf = ConvertDDToDMS(lon,true);
            tempstr += lf['deg']+'°'+lf['min']+"'"+(Math.round(lf['sec']*10)/10).toFixed(1)+'"'+lf['dir'];
            $('#positiontext').html(tempstr);
        }
        else $('#positiontext').html(lat+',<br />'+lon);
    }
    
    //public
    
    /* changes format of position data (longitude, latidue)
     * return: 'deg'|'decimal'
     */
    this.switchLocFormat = function() {
        locformat = !locformat;
        refreshLocDisplay();
        if (locformat) return 'deg';
        else return 'decimal';
    };
    
    /*
        collects values for average speed
          s: speed value to add
          resettime: value != 0 defines max time span (value in hours!), in this case reset the average collection! 
        
        - makes timestamp from hours
        - stores timestamp internally
        - does NOT auto save averagespeed persisently (must be done seperately, eg. on resetAutoFade/resetHud, or OnPause)

        akt. Implementation: 
        - gleich bei Beginn Gruppe mit 2, dadurch alle 2 s ein neuer Wert
        - dann Gruppen gestaffelt 2,4,8,16 
        - Gruppenerweiterung nur, wenn treshhold == gewünschte max. Länge der Liste erreicht. (z.B. 5400)
        - wenn max. Länge der höchsten Stufe (16) erreicht, werden alte Werte gelöscht.
        - der einzige Sinn der Gruppierung ist Performance-Einbruch des JS zu verhindern,
          durch Tests könnte der treshhold bestimmt werden
        - wenn bei Basisgruppe =2 bleibt --> Werte von 3 Stunden
        - NICHT beachtet ist bisher, dass alte Werte gelöscht werden sollten, wenn 24h oder mehr um sind, OHNE dass Tachometer benutzt wurde
          (ist vielleicht erstmal ganz gut so :-)
          
         TODO: neue Implementation: 
         - einfach 2 Werte speichern: summe und Anzahl. fertig!.
         - man bräuchte aber 2 Summen, nämlich die gesamte und die bis vor Ablauf der Gleitwerte
         --> da einzige Problem ist nun der *gleitende* Mittelwert
         - deshalb auch Gruppen speichern, genau 1 je Programmstart.
         - da Zeitüberchreitung des Zeitfensters (z.B. 24h) sowieso nicht bei laufender Messnung beachtet werden soll,
    */
    this.averageSpeed = function(s,resettime) {
 
 		var i,cas,clength; // used several times
 		
		
		if (resettime && resettime > 0) {
		
			// time value not yet used
			
			delete average_list;	
		}
		else {
			// TODO: völlig neue Berechnung!
			// first collect values
			average_grouplist.push(Math.round(s*100)/100);		
			// check if group is full
			var gs = average_grouplist.length; // only if gs is used again
			if (gs >= average_groupsize)  {
				// now add group to main list by making average value and clear grouplist
				 cas=0;
				 for(i=0;i<average_groupsize;i++) {
				 	cas += average_grouplist[i];
				 }
				cas = cas / average_groupsize;
				//app.Debug(average_grouplist);
				//app.Debug(cas);
				average_list.push(cas);
				// the main list will get cutted if too large
				clength = average_list.length;
				if (clength>average_treshhold) {
					averagelist.shift(); // or first change group size!
					clength--;
					//TODO: make startindex instead of shift, the array will cutted by storing/restoring + restarting app
				}
	
				 // noe get average from main list
				 //if (clength % 100 ==0) app.Debug ('avg main list size:'+averagelist.length);
				 //if (clength) app.Debug ('avg main list size:'+average_list.length);
				 //if (clength) app.Debug (average_list);
				 app.Debug(clength);
				 cas=0;
				 for(i=0;i<clength;i++) {
				 	cas += average_list[i];
				 }
				 cas = cas / clength;
				 $('#averagespeedtext').text(Math.round(cas));
	        
				average_grouplist.length = 0 ; // slowest	        
			}
		} // else // resettime

    };
 
 	/* save function  for average speed
 	 * 
 	 * - seperate from generating for performance reasons (should be used only on pause / quit )
 	 * - makes string of array
 	 * - if array empty save empty string!
 	 * 
 	 * return: true: success; false:error
 	 */
 	this.saveAverage = function () {
	 		
	 	var str = '';
	 	var clength = average_list.length;
	 	if (clength) {
	 		try {
	 			str = JSON.stringify(average_grouplist);
	 		}
	 		catch(e) {
	 			app.Debug(e);
	 			return false;
	 		}
	 		app.Debug(str);
	 		app.SaveText(storage_tachoaverage,str);
	 	}
	 	return true;
 	};
 	/* load function for average speed
 	 * - makes array of object out of string with JSON.parse
 	 * - error while loading or empty string leaves array unchanged
 	 * return: true=success, false=nothing (sensible) loaded
 	 */
 	this.loadAverage = function() {
 		var str = app.LoadText(storage_tachoaverage,'');
 		var err=0;
 		if (str) {
 			// for the unusual case of loading after init of app delete list:
 			if(average_grouplist.length) average_grouplist.length = 0;
 			try {
 				average_grouplist = JSON.parse(str);
 			}
 			catch(e) {
 				app.Debug(e);
 				err=1;
 				average_grouplist = new Array();
 			}
 		}
 		if (err) return false;
 		else return true;
 	};
    /*
        sets the maxspeed
        - newmaxspeed: only accepted if > current maxspeed
        - newmaxspeed: < 0: reset maxspeed with value (like in this.tachoRange)
        - auto saves maxspeed persisently
    */
    this.maxSpeed = function(newmaxspeed) {
        
        
        if(newmaxspeed > maxspeed || newmaxspeed < 0) {
            maxspeed = (newmaxspeed<0) ? -newmaxspeed  : newmaxspeed;
            app.SaveNumber(storage_tachocurrentmax,maxspeed); // is called quite often shortly after reset but not more often than once a second
            $('#maxspeedtext').text(maxspeed);
        }
       
        return (maxspeed);
        
    };
    
    this.change = function(newlocdata) {
		//app.Debug('loc change');        

        // if provider == network, speed has no reasonible value
        // so keep old value unless gps
        // TODO: alle Änderungen auch ohne GPS wenn möglich - z.B.  für initiale Werte
        // oder != 0 abfragen : entweder Wert !=0 oder nur von gps
        
        if (newlocdata.provider.toLowerCase() == "gps") {
			clearGpsWarning();
			
            lastspeed=speed;
            // rounding saves a lot of space when converting values to string
            speed =  newlocdata.speed;
            if (speed < 0) speed = 0; // for the case of calculation or rounding errors
            //(if speed is momentarily <0 this can disturb statictic/display functions of app)
            speed *= 3.6; // km/h
            // kmhspeed = speed * 3.6;  // planned
            // mphspeed = speed * 0.44704; // planned
            // knspeed = speed * 0.514444; // planned
            
            //currently not used $('#bearingtext').text(newlocdata.bearing+'°');
            //currently not used $('#bearinginfo').text('GPS');


	        //if (speedtest<50) speedtest+=0.9;
	        //else speedtest+=9;
	        //speed=speedtest;// test value for debug
	        //speed=42;
	        
	        //TODO: turn on: this.averageSpeed(speed);
	        this.maxSpeed(speed);
	        
	        var ss = "";
	        //sieht Scheiße aus: if (speed < 10) ss = speed.toFixed(1); //eine Kommastelle bei <10 km/h
	        // Kommastelle nur wenn hinterer Teil ganz kleine Schrift
	        ss = Math.round(speed);
	        
	        $('.speed').text(ss);
	
	        if (cssgauge_visible) { // flag for performance
		        // correct scale if >1000 or <1000
		        if (speed >= 1000 && lastspeed<1000) dona_text_scale(dona_scale4);
		        else if (speed < 1000 && lastspeed>=1000) dona_text_scale(dona_scale3);
		        
	        	if (speed > 0) this.tachoRange(speed); // must not be <= 0  (accidently)
	        	gauge.setValue(speed); // hier den exakten float value nutzen
	        }
        }
        else {
            //$('#bearinginfo').text('Sensor');
            // gpswarning is controlled by block above only
        }
        
		// get always these values !:
		// but only set if not 0
        if (newlocdata.latitude!=0) lat = newlocdata.latitude; // TODO: check if you should round!
        if (newlocdata.longitude!=0) lon = newlocdata.longitude;    // TODO: check if you should round!
        if (newlocdata.altitude!=0) alt = newlocdata.altitude; // TODO: check if you should round!
        //currently not used  $('#accuracytext').text(newlocdata.accuracy); 
        // analog speed testing: 
        


        //step = (speed - lastspeed) / 4;
        //stepcount=0;
        //dspeed = lastspeed;
        // window.setTimeout(this.setStep,250);

        //test
//        lat = 40.1641164;
//        lon = -7.8928645;

        //update geolocation
        refreshLocDisplay();
        
        //update altitude
        
        $('#altitudetext').text(Math.round(alt));
    };
    
    this.isHud = function() {
    	return hud;
    };
    
    /* switch the hud (mirroring) on and off
    - sets one specific state if parameter setto is set ('on'|'off')
    */
    this.switchHud = function(setto) {
    
        if (setto=='on') hud = true;
        else if (setto=='off') hud = false;
        else hud = !hud; 
        
        var scale = hud ? -1 : 1;

        $("#display-container").css({
            'transform' : 'scaleX('+scale+')',
            '-webkit-transform' : 'scalex('+scale+')',
            '-moz-transform' : 'scaleX('+scale+')'
        });
		if (hud) {
		  $('.skin').addClass('skin-minimal');
		  app.SetScreenMode('Full');

		}
		else {
		  $('.skin').removeClass('skin-minimal');
		  app.SetScreenMode('Normal');
		}
    };
	
	/*
	  setzt Tacho Wertebereich in Anzeige analog hoch 
	  - newvalue enthält eine aktuelle Geschwindigkeit, die ausgewertet werden muss!
	  - wenn newvalue < 0, Max. Wert auf abs(newvalue) direkt gesetzt anstatt zu erhöhen
	  - wenn newvalue zufällig 0 -> nichts tun
	  - Automatische Wertebereich-Erhöhung kann real nicht abgeschaltet werden, sondern wird
	    im Menü lediglich auf niedrig oder hoch zurückgesetzt :-)
	  - TODO: value gleich setzen, wenn Bereich geändert, am besten auch, wenn nicht geändert
	*/
	this.tachoRange = function(newvalue) { 

    	if(newvalue) {

    	    var dochange = false;
    	    
    	    if (newvalue > tachorange
                && $('#cssgauge').is(':visible') // nichts tun wenn ananlog nicht sichtbar!
            ) { 
                
                // do NOT increase but directly calculate new; the divisor == step to round up
                // (this avoids jumping 5 times when starting while having e.g. 100km/h)
                // TODO: 40th step does not work properly
                if (newvalue >= 500) tachorange = Math.ceil(newvalue / 500)*500;
                else if (newvalue >= 100) tachorange = Math.ceil(newvalue / 100)*100;
                else if (newvalue >= 20) tachorange = Math.ceil(newvalue / 50)*50;
                else if (newvalue >= 10) tachorange = Math.ceil(newvalue / 20)*20;
                else tachorange  = 20;
                
                app.Debug("extended range:"+tachorange);
    	        dochange = true;
            }
            else if (newvalue < 0) {
                // this makes it possible to reset to a range
                tachorange = -newvalue;
                dochange = true;
            }
            
            // nun ist tachorange korrekt berechnet, falls nicht größer, nichts tun
            if (dochange) {
                
        	    var minors = 2;
				var maj = tachorange / 10; 
				var split = 6;
				
				if (tachorange<=10) {
				    minors = 2;
				}
				else if (tachorange<=20) {
				    minors = 2;
				}
				else if (tachorange<=50) {
				    minors = 5;
				}
				else if (tachorange<=200) {
				    minors = 2;
				}
				else if (tachorange<=300) {
				    minors = 3;
				}
				else if (tachorange<=400) {
				    maj = 50;
				    minors = 5;
				}
				else if (tachorange<=500) {
				    
				    minors = tachorange / 100;
				}				
				else {
				    minors = 2;
				}
				    
				
				var steps = tachorange / maj;
				// TODO: autoadjust by checking amount of steps
			    split = Math.floor(steps / 3 * 2);
				
        	    gauge.config({
					'wrapper':'cssgauge-wrapper',
					'gauge':'cssgauge',
					'size':'auto', // not yet implemented !
					'maxRange':tachorange,
					'majorStep':maj, // must be < maxRange and reasonable adjusted
					'minorTicks':minors, // should be between 0 and 5
					'overallAngle':270, // degrees, better < 340
					'value':0 // must be < max Range
        	    });
        	    // some skin classes must be set again:
        	    //if(hud)	$('.skin').addClass('skin-minimal'); // TODO: problem if multiple adds possible

        	    app.SaveNumber(storage_tachorange,tachorange);
            }
    	}
    	return tachorange; 
	};
	
	
	// construct
	
    // current maxspeed
    this.maxSpeed(-app.LoadNumber(storage_tachocurrentmax,1)); // neg. value forces set, default 1, because -0 is just 0
    // current average speed
    this.loadAverage();
    

} // GpsTools


/*  AutoSettings
    sucht per jquery Elemente aus dem DOM, deren Zustand in 
    localStorage gespeichert wird, um z.B. Programmeinstellungen
    wiederherstellen zu können.
    - abhängig von bestimmten Konventionen im HTML:
        - id muss gesetzt sein
        - class 'switcher' 
        - Funktionen sollten Zustandsänderung an AutoSettings weitergeben
          (Bsp. hier siehe 'setRadio()' und 'switchClass()'
        - Zustände sollten nicht außerhalb von AutoSettings in vars gespeichert 
          werden
	
	TODO: extern (interface) alles mit boolean!

          
    TODO: PROBLEM: funktioniert in App nicht oder schlecht, 
        - Verhalten von get (kann auch *undefined* liefern!) wurde repariert
        --> Timing Problem (wegen jQuery?) besteht immer noch
        - besser wäre, alle switcher bei Programmstart in Array aufzunehmen, wenn
          load scheitert, dies würde auch Array-Vergrößern bei erstem Switch 
          sparen
*/
//class
function AutoSettings(newstoragename,newsetclass) {
    //private
    var data = new Array();
    var storagename = '';
    var setclass = 'switched-on';
    var check = "";
    
    var that = this;
    
    //public
    
    
    /*  speichert in storage wenn möglich
        - gibt false zurück, wenn speichern nicht möglich
        - verändert Struktur 'data' nicht
    */
    this.save = function() {
        
        if(storagename!='' && data.length!=0) {
            var str = JSON.stringify(data);
            window.localStorage.setItem(storagename,str);
            return true;
        }    
        return false;        
        
    };
    
    /*  lädt von storage wenn möglich
        - gibt false zurück, wenn laden nicht möglich
        - verändert Struktur 'data' nicht, wenn laden nicht möglich
    */
    this.load = function() {
        
        if(storagename!='') {
            var str = window.localStorage.getItem(storagename);
            if(str!==null) {
                data = JSON.parse(str);
                return true;
            }            
        }    
        return false;        
    };

    /* findet Element oder fügt es hinzu
        - gibt index des Elementes zurück oder -1 im Fehlerfall
    */
    this.added = function(name) {
        var i;
        var l = data.length;
        for(i=0;i<l;i++) {
            if(data[i]['name'] == name) {
                return i;
            }
        }
        
        if(i>=data.length) {
            var a = new Object();
            a['name'] = name;
            a['value'] = 'false';
            data[i] = a;

            return i;
        }
        
        return -1;
    };
    
    /*  initialisiert alle Switches
        - ändert HTML der entsprechenden Elemente
        - liest aktuelles 'data', versucht intern keinen 'load' oder 'generate'
    */        
    this.initall = function() {
        
        var i;
        var l = data.length;
        for(i=0;i<l;i++) {
            if(data[i]['value'] == 'false') {
                $('#'+data[i]['name']).removeClass(setclass);
            }
            else {
                $('#'+data[i]['name']).addClass(setclass);
            }
        }
    };

    /*  liest einen Wert aus Settings liste
        liefert undefined wenn Wert nicht vorhanden
    */
    this.get = function(name) {
        var i;
        var l = data.length;
        for(i=0;i<l;i++) {
            if(data[i]['name'] == name) {
                return data[i]['value'];
            }
        }
        
        return undefined; // TODO: lieber String 'unset'
    };
    
    /*  setzt einen Status und erzeugt Element, wenn nicht vorhanden
        - value string!! 'true' und 'false' werden behandelt
    */
    this.set = function(name,value) {
        
        if(name!=undefined) {
            var i = this.added(name);
            if(i!=-1) {
                data[i]['value'] = value;
                return true;
            }           
        }
        return false;
    };
    
    
    /* return: true: on, false: off
 		- value: if given sets to this (must be string 'true'|'false') (TODO: test!)
 		TODO: alles mit normalem true|false (keine Strings)
	       TODO: id statt elem, da eh wieder zurück referenziert werden muss
     */
    
    this.switchit = function(elem,value) {
        
        var id = $(elem).attr('id');
        var sw = $(elem).hasClass(setclass);
        var setto = (value == 'true') ? true : false; // value undefined also leads to false
        
        if (sw && setto) return true; // prevent multiple set of class
        
        if(sw && !setto) {
        	// remove class may sometimes be called when there is nor more class - without effect
            $(elem).removeClass(setclass);
            this.set(id,'false');
        }
        else {
            $(elem).addClass(setclass);
            this.set(id,'true');
        }

        this.save();
        return !sw;
    };
    
    /* im Gegensatz zum switch muss bei radio bei allen
       betreffenden Elementen (klasse) das Element gesetzt/erzeugt werden
       TODO: id statt elem, da eh wieder zurück referenziert werden muss
    */
    this.radio = function(klasse,elem) {
        
        // alle der klasse auf false
        $(klasse).removeClass('switched-on');
        $(klasse).each(function() {
            that.set($(this).attr('id'),'false');
        });
        
        // gesetztes auf true
        $(elem).addClass('switched-on');
        this.set($(elem).attr('id'),'true');
        
        this.save();
    };

    
    //construct
    if(newstoragename) storagename = newstoragename;
    if(newsetclass) setclass = newsetclass;
    if(this.load()) this.initall();
}


/* manages Visibility of menus or cards or any HTML elements given by id (always called 'menu' here)
 * - 
 * - push() and pop() make sure the caller does not need to know order or type or id of open menu
 * - TODO: function clear/rewind
 * - TODO: choose to not hide lower on push 
 * - TODO: save state (show/hide) of each entry
 * - TODO: find error while OnBack (if any)
 */
// class
function PopupStack() {
	
	// private:
	
	var stack = new Array();
	/* adds a menu to the stack
	 * - callback will be used on pop for additional actions on pop
	 * - id must be the name used by HTML element id  
	 */
	
	//public:
	
	/* code for the *current* project, 
	 * TODO: to make this class independently provide callback mechanism!
	 */
	this.doOnChange = function() {
	    window.scrollTo(0,0);
	    resetMenuFade();
	};
	
	this.push = function(id,callback) {
	
		var stackentry = new Object( {
			'id': id,
			'callback' : callback
		});
		
		// we hide the last stackentry and
		if (stack.length) {
			var last = stack[stack.length-1];
			$('#'+last.id).hide(); // !jQuery
		} 
		// now show the new menu
		// id is always stored without the #, user can decide to write # or not
		if (id.charAt(0)=='#') id = id.substr(1,id.length-1);
		//app.Debug(id);
		
		$('#'+id).show(); // jQuery!		
		stack.push(stackentry);
		//app.Debug(stack);
		
		this.doOnChange();
	}; 
	
	/* removes a menu from stack
	 * - return: id of popped menu
	 * - if stack empty, do nothing and give back emptys string
	 */
	this.pop = function() {
		
		if (stack.length>=1) {
			var entry = stack.pop();
			// hide the menu to be popped
			$('#'+entry.id).hide(); // !jQuery
			if(stack.length) {
				var last = stack[stack.length-1]; // now the previous is the topmost
				$('#'+last.id).show(); // !jQuery
			}

			this.doOnChange();
			return entry.id;
		}
		else return '';
	};
	
	/* hides current element and empties stack
	 * 
	 */
	this.clear = function() {
 		if(stack.length) {
 			$('#'+stack[stack.length-1].id).hide();
 			stack.length = 0; // clear all
 		}
	};
	
	/* returns the currently visible menu of stack
	 * - does nothing but returning id,
	 * - returns FALSE if no menu there, else the id string without '#'
	 * - just use this method to check for an empty stack! 
	 */
	this.current = function () {
		if (stack.length) {
		  var e = stack[stack.length-1];
		  if (e.id) {
		      app.Debug(e.id);
		      return e.id; // TODO: check if can be written like that!
		  }
		}
		//app.Debug('stack empty');
		return false;
	};	
} // class PopupStack


/* DisplayBox
 * - outer wrapper = display-box -> border etc.; size adjusted with css (name of wrapper not important)
 * - inner = diplay-text -> size adjusted with transform scale - can be div and still fit to text???
 *  
 */// class
function DisplayBox (newid,mode) {

	var id;
	var boxRef = null; // element in DOM
	var textRef = null; 
	var primary = false;
	var visible = true;  // for toggle - and performance
	var firstvisible = false;
	var teststring = newid;
	
	/* gibt Namen zurück
	 * 
	 */
	this.name = function() {
		return id;
	};
	
	this.testString = function(newstr) {
		if((typeof newstr != 'undefined') && newstr) teststring = newstr;
		return teststring;
	};
	
	this.show = function() {
		if(!visible) {
			$(boxRef).show();
			visible=true;
		}
	};
	
	this.hide = function() {
		if(visible) {
			$(boxRef).hide();
			visible=false;
		}
	};
	
	this.isVisible = function() {
		return visible;
	};
	
	/* sets or removes class for first *visible* display
	 * - value stored
	 * TODO: caller must ask whether he wants digitalspeed either - or not
	 */
	this.setFirst = function(isfirst) {
		if ((isfirst && firstvisible) || (!isfirst && !firstvisible)) return;
		
		
		if (isfirst) {
			$(boxRef).addClass('first-display');
			//app.Debug('first set to '+id);
			firstvisible = true;
		}
		else {
			$(boxRef).removeClass('first-display');
			app.Debug('first removed from '+id);
			firstvisible = false;
		}
	};
	
	/* passt die Größe dem umgebenden div (settings.wrapper) an
	 * - unabhängig, da bei jedem resize benötigt.
	 */
	this.scale = function(dim) {
		// manage scale + corrected position!
		// TODO: CSS scale origin des .gauge oben links
		// - the width, height of wrapper are always the innermost value 
		// - checks if width or height is limiting ("bounding box")
		if (boxRef==null || textRef==null) return;
		
		var ws =  $(boxRef).width() /  $(textRef).outerWidth(); //TODO: save values
		var hs =  $(boxRef).height() /  $(textRef).outerHeight();
		//console.log(ws+'x'+hs);
		//app.Debug(ws+'/'+hs);
		
		if(dim) {
			if(dim=='width') {
				scale = ws;
			}
			else {
				scale = hs;
			}			
		}
		else scale = (ws < hs) ? ws : hs;
		
		// move to proper position too
		// einmalig in die Mitte des umgebenden div translaten und dann scale-origin in der Mitte lassen? 
		var x = y =0; 
		
		// TODO: should also work with transform-origin 50% 50% 0 and center text by top/left values
		
		$(textRef).css({
			'transform-origin':'50% 0 0',
			'transform':'scale('+scale+','+scale+')'
		});		
		
		if(dim) {
			if(scale==ws) {
				//refit height
				//$(boxRef).css('height',$(boxRef).outerHeight()*scale); // consider box-sizing
				var newh = ($(textRef).height()+12) * scale; // need correction is +padding +border (due to box-sizing:border-box) 
				$(boxRef).css('height',newh+'px');
			}
			else {
				//refit width
				//$(boxRef).css('height',$(boxRef).outerHeight()*scale); // consider box-sizing
				var neww = $(textRef).width() * scale; 
				$(boxRef).css('width',neww+'px');				
			}
		}
	};	
	
	this.resize = function(x,y,dim) {
		
		$(boxRef).css({
			'width':x+'px',
			'height':y+'px'
		});
		// try to center text into wrapper box
		$(textRef).css({
			'left':($(boxRef).innerWidth() - $(textRef).width()) / 2 + 'px' 
		});

		this.scale(dim);
	};
	
	// construct displayBox
	
	id=newid;
	boxRef = document.getElementById(newid);
	//console.log(boxRef);
	textRef = $('.display-text',boxRef);
	
	$(boxRef).show(); // in case it is disabled initially // hide depending on app settings is done later
	//$(boxRef).removeClass('display-frame');
	//$(boxRef).addClass('display-box');
	if(mode) primary = true;
	
	// fix inner text box size to preset text
	// change to block important for scale (must be inline before for getting text size) 
	$(textRef).css({
		'width':$(textRef).width(),
		'height':$(textRef).height(),
		'display':'block',
		'position':'absolute'  
	});
	var w = $(boxRef).width(); // save this for the object
	this.resize(w,0,'width'); // TODO: make box to boxsizing:content-box!
} // class displayBox

/* verwaltet Objekte vom Typ 'displayBox'.
 * - nicht nur List-Funktionen sondern auch visuelle Interaktionen und Abhängigkeiten (z.B. Schriftgrößen)
 * - id_maxwidth: id von HTMl-Element, definiert, welches durch seine Schriftgröße die Größe der anderen bestimmen soll
 * 
 * TODO: Idee nicht "List", sondern Container, der Tacho, andere Anzeigen enthält (auf der "Wrapper-"Stufe"), abgeleitete Objekte
 *   je nach Funktion, allgemein vor allem Aufnahme der positionierungs- und Größendaten + Funktionen  
 */
function DisplayBoxList(id_maxwidth) {
	var idmaxwidth;
	var list = new Array();
	
	/* adds an element to list
	 * id: id of HTML tag
	 */
	this.add = function(id,reset_text) {

		if (id.charAt(0)=='#') id = id.substr(1,id.length-1);
		var box = new DisplayBox(id,(id==idmaxwidth)); // ! boolean result for 2nd param
		list.push(box);
		//debug
		//for (var i=0;i<list.length;i++) app.Debug('list '+i+' '+list[i].name());
		//now reset text content of box
		if(reset_text)
			$('.display-text','#'+id).text(reset_text); // TODO: check if this destroys inner of .display-text!!	
		return box;			
	};
	
	/* returns object with certain id
	 * - TODO: provide function to return object by index, or return all (or at least length of array)
	 */
	this.get = function(id) {
		for(var i=0;i<list.length;i++) {
			if(list[i].name()==id) return list[i];
		}	
		return null;
	};
	
	/* returns true if all displays (except digitalspeed) are hidden
	 * 
	 */
	this.noneVisible = function() {
		for(var i=0;i<list.length;i++) {
			if (list[i].name()!='digitalspeed' && list[i].isVisible()) return false;
		}
		return true;
	};
	
	/* verschiedene Einpass-Funktionen
	 * - ! z.Z. nur für stapel übereinander geeignet
	 * TODO: immer noch fehler, da in positionDisplays digitalspeed nicht mit gerechnet, aber hier mit verarbeitet
	 * TODO: nur gerade sichtbare einberechnen
	 * TODO: style für :first dynamisch für ersten sichtbaren
	 */
	this.scaleTo = function(x,y) {
			var i;
			
			if(list.length>=4) { // just to be saver from errors
				// get visibles:
				// - there are just 2 possible entries which need the border (can be !first)
				// - TODO: this as a general rule/loop
				list[0].setFirst(true); // digitalspeed
				list[1].setFirst(true); // time
				var check = (!list[1].isVisible()); // hope check is getting boolean			
				list[2].setFirst(check); 
				check = (!(list[1].isVisible()|| list[2].isVisible()));
				list[3].setFirst(check); 
			}			
			
			var c = 0;
			// ! only works when #digitalspeed is first in list !
			// ! counts from second entry 
			for(i=1;i<list.length;i++) { // always loop forward here!
				if (list[i].isVisible()) {
					c++;
				}
			}


			if(y==0) { // normal screen wide
				for (i=list.length-1;i>=0;i--) {
					list[i].resize(x,0,"width");	
				}
				app.Debug('scaled to max h');				
			}
			else {
				//app.Debug('visible displays: '+c);
				var dy = y/c; // c generated above
			
				for (i=0;i<list.length;i++) {
					if (list[i].name()=='digitalspeed') {
					    // TODO: do nothing here
						//list[i].resize(x,0,"width");
					}
					else {
					//TODO: *must* calculate outerWidth(true)
					//on .display-box for using space
						list[i].resize(x,dy,"");						
					}	
				}
				app.Debug('scaled to h ='+dy);								
			}
	};
	// construct
	idmaxwidth = id_maxwidth;
	if (idmaxwidth.charAt(0)=='#') idmaxwidth = idmaxwidth.substr(1,id.length-1);	
} // class displayBoxList


// in browser global var important:
var gauge = null;

function fadeMenus() {
	//if(menustack.current()!==false) $('.dialog').fadeOut();// TODO: fade mit complete function
	menustack.clear();
}
var menutimeout = false;
function resetMenuFade() {
	if(menutimeout!==false) clearTimeout(menutimeout);
	var newtimeout = 2*1000*60; // 2 miin
	if(menustack.current()=='infocard') newtimeout*=10; // 20 min
	menutimeout = setTimeout(fadeMenus,newtimeout);
}
var fadetimeout = false;

// only called onInit and OnBack
// function on ice since we don't need infos on the main screen now
/*function resetAutoFade() {
	
    app.SetScreenMode( "Normal"); // show statusbar    
    app.PreventScreenLock(false); // display timeout on again

    if(fadetimeout!==false) clearTimeout(fadetimeout);

    $('.autofade').show();
    $('.test').css({ 'opacity': '1.0' });

    
    // TODO: class "preventfade" oder so
    // is now handled by PopupStack :-)
    if(!menustack.current()) {
        fadetimeout = setTimeout(fadehud,5000);
		app.Debug("fade timeout set, since no menus open");
    } else app.Debug("fade DENIED");
}
*/
function fadehud() {
    
    // restart counter if something is in the way:
    // TODO: class "preventfade" oder so
    // TODO: hidden abfrage geht nicht :-(
    if(!menustack.current()) {
    	// TODO: use .autofade again for color/backgroundcolor of several elements e.g. gauge 
        //$('.autofade').fadeOut('slow');
		$('#hg').addClass('hgchange');
    }
    else clearTimeout(fadetimeout);
}


/* does only the lock and fullscreen
 * - no fading or hiding (until needed again) 
 * - TODO: fullscreen geht evtl.erst durch nächste grafische Änderung (???)
 */
function resetHud() {

    $('.autofade').show();
    $('#hg').removeClass('hgchange');
    if(fadetimeout!==false) clearTimeout(fadetimeout);

	if (!menustack.current()) {
	    //app.SetScreenMode( "Full"); // deaktiviert wegen Einfluss auf tap-event :-(
        fadetimeout = setTimeout(fadehud,5000);
	}	
	else {
	    //app.SetScreenMode( ""); // show statusbar    
	    //app.PreventScreenLock(false); // display timeout on again
	}
	
	// TODO: make info of advertising here :-)
	if (layout_gauges < 1 && !menustack.current()) $('#no-gauges').show();
	else $('#no-gauges').hide();
}


/* setzt analog und digital-Tacho korrekt einzeln oder übereinander
    - da es nur gleiche Aufrufe gab, jetzt keine Parameter mehr- Elemente direkt genutzt
    - settings Struktur muss initialisiert sein!
    - NEW: sub-elements ar hidden when whole tacho is hidden
*/
function setTachoLayout() {
     
    if (settings.get('tachoswitch')!='false') {
    	
	  $('#tacho-container').show();
	 
	                   	
	    var a;
	    var d;
	    if (settings.get('digitalanalog')!='false') a = d = true;
	    else {
			a = (settings.get('analog')=='false') ? false:true;
			d = (settings.get('digital')=='false') ? false:true;
		}
	
	    if(a && d) {
	        $('#cssgauge-wrapper').show(); cssgauge_visible = true;
	        $('#digital-on-analog').show();    
	        displayDigitalspeed.hide(); $('#digitalspeed-wrapper').hide();   
	    }
	    else if (a && !d) {
	        $('#cssgauge-wrapper').show(); cssgauge_visible = true;
	        $('#digital-on-analog').hide();
	        displayDigitalspeed.hide(); $('#digitalspeed-wrapper').hide();   
	    }
	    else if (!a && d) {
	        $('#cssgauge-wrapper').hide(); cssgauge_visible = false;
	        displayDigitalspeed.show(); $('#digitalspeed-wrapper').show();
	    }
	    else {
	        $('#cssgauge-wrapper').hide();  cssgauge_visible = false;
	        displayDigitalspeed.hide(); $('#digitalspeed-wrapper').hide();
	    }
	}
	else {
		$('#tacho-container').hide();
		cssgauge_visible = false;
		displayDigitalspeed.hide();
	}

}


//Add messages to log.
// log is an array since we don't when we can first access the output we like
// thus array can be read later
logarray = new Array(); // global
function Log( msg ) 
{ 
    logarray.push(msg);
    if (app_browsermode) app.Debug(msg);
    /*
if( txt.GetLineTop( txt.GetLineCount() ) >= 0.2 )  
        log.shift(); 
    log.push( msg + "\n" ); 
    txt.SetText( log.join("") );
*/
    //txt.SetText(msg);
} 

var fontsizes = new Array();
/* proper sizes and positions for displays and fonts
    - should only run on startup and when screen rotates
    initial: true|false (true=font-sizes neu berechnen,
            ggf. müssen dazu zwischenzeitlich alle Digital-Displays aktiviert werden
*/
var dona_scalebase = 0;
var dona_scale3 = 1.33;
var dona_scale4 = 1;
var dona_space = 0;

function dona_text_scale(scale) {
    $('#dona-text').css({
        '-webkit-transform':'scale('+scale+','+scale+')',
        'transform':'scale('+scale+','+scale+')'
    });
}

/* berechnet alle Größen und Positionen der Anzeigen
 * - initial: gesetzt wenn bei Programmstart aufgerufen
 */
function scaleDisplays(initial) {
    
    app.Debug("scaleDisplays: "+(initial ? 'app start' : 'normal'));
 
    // get vars and test, since we got problems with body.client... vs. window.innerheight
	var screen_w = window.innerWidth
	|| document.documentElement.clientWidth
	|| document.body.clientWidth;
	
	var screen_h = window.innerHeight
	|| document.documentElement.clientHeight
	|| document.body.clientHeight;

    var w = 0;
    var h = 0;
    
    
    if (screen_w <  screen_h) {
       isLandscape = false;
       w = screen_w;
    }
    else {
       isLandscape = true;
       w = h = screen_h;
    }
    
	// set the positioners to a certain initial width:
	// (otherwise displays can not init to a certain size)
	if(initial) {
    	$('.positioner').css('width',screen_w); // first set screen width for all
	}
    
    //app.Debug (w2);
    
    // gauge will be centered later
    $('#cssgauge-wrapper').css({
    	'width':w+'px',
    	'height':w+'px'
    });
    gauge.scale();


        
//    else $('#cssgauge-wrapper').css({
//    	'left':'10px',
//    	'top':'10px'
//    });
    
    // zentriere alle Dialoge:
    // ! z.Z. keine Dialogverarbeitung *außer hori. zentrieren*
    // - automatische Abfrage ob Dialog größer Bildschirm
    // - Korrekturwert für border und padding
    // TODO: man könnte auch wrapper der dialoge mit layout versehen und diesen in Größe variieren lassen
    //       mit transition dann weiche Übergänge 

    //app.Debug('screen:'+screen_w+'x'+screen_h);

    /*
    $('.dialog').css('top',function(index,value){
        var hoff = (screen_h - $(this).outerHeight()) / 2;
        if (hoff < 10) hoff = 10;
        var woff = (screen_w - $(this).outerWidth()) / 2;
        $(this).css('left',woff+'px');
        return hoff+'px';
    });
    */
   
	// TODO: center without JS ??
    $('.dialog').css('left',function(index,value){
        var woff = (screen_w - $(this).outerWidth(true)) / 2;
        return woff+'px';
    });
    
    // make some dialogs height depending on main menu
	// outerheight -> corresponds to box-sizing!
	$('#moresettingsdialog,#tachosettingsdialog').css('min-height',$('#settingsdialog').outerHeight()+'px');
	
	// jetzt können alle versteckt werden:
    //$('.dialog').hide(); // TODO: auch wenn nicht initial??

    if (initial) {    
    
	    // digital on analog speed size
	    // now orientated to position and size of #cssgauge (not screen at all!)
	    // ! note that this is only needed when *initial* since it is scaled together with gauge 
		var cssgaugewidth = $('#cssgauge').width(); // here NOT outerWidth! 
	    var wdona = cssgaugewidth * 0.4; 
	    var newfontsize = wdona/2;
	    
	    $("#digital-on-analog").css({
	        'width':wdona+'px',
	        'height': newfontsize*1.2+'px',
	        'border-radius':newfontsize/2+'px'
	      });
	    
	    $("#digital-on-analog").css({
	        'left': (cssgaugewidth - $('#digital-on-analog').width()) / 2,
	        'top':  (cssgaugewidth - $('#digital-on-analog').height()) / 2
		});

	    // size and position of info (km/h) on analog must depend on cssgauge
	    // TODO: simpler calculation??
	    $('#info-on-analog').css({
	        'width':cssgaugewidth/2.7+'px',
	        'height':'auto',
	        'top':cssgaugewidth*0.73+'px',
	        'left':((cssgaugewidth-(cssgaugewidth/2.7))/2)+'px', // must be same ratio like in width
	        'font-size':cssgaugewidth/20+'px',
	        'line-height':'1em'
	    });
	
	    //$('#digital-on-analog .speed').css({'font-size':''+newfontsize+'px'});
	    // position digital
	    // dona-text is a div inside:
	    
	    // dona-text 
	    // - save width with max. digits (4)
	    // - make the width fixed
	    // - now you scale to a) size with 4 digits b) to bigger size with 3 digits
	    // - for b) you must calculate the difference in width (about 1/4 == 1 digit)


        dona_scalebase = $('#dona-text').width(); // must be 0000 in this moment!
        dona_space = wdona * 0.85; // max width we want the number have to, because need border
        
        $('#dona-text').css({
            // the width will be set her ONCE
            'width': dona_scalebase + 'px'
        });
        
        // compute scale for 4 digits (0000):
        dona_scale4 = dona_space / dona_scalebase;
        dona_scale3 = dona_space / (dona_scalebase*0.75);
        dona_text_scale(dona_scale3);
        // replace inital 0000 text
        $('#dona-text').text('0');

	    // only correct centered position
	    // - the css width is not changed anymore
	    // - must take width of #digital-on-analog as ref
	    $('#dona-text').css({
	        'left': ($('#digital-on-analog').width() - $('#dona-text').width()) / 2 + 'px', 
	        'top': ($('#digital-on-analog').height() - $('#dona-text').height()) / 2 + 'px'
	    });
    }
}    // scaleDisplays

/* adjusts positions, proportions and sizes of displays,
 * depending on which display is currently visible
 * - also perfoms scaling of displays
 * 
 * - TODO: Idee: breite,höhe und layoffset in Object DisplayBox integrieren - dort positioner finden lassen (.parent() in jQuery)
 * - ! do not set height of positioner but of wrapper
 */
function positionDisplays() {
		
	var hscreen = window.innerHeight
	|| document.documentElement.clientHeight
	|| document.body.clientHeight;
	var screen_w = window.innerWidth
	|| document.documentElement.clientWidth
	|| document.body.clientWidth;
	
	// TODO inside display objects??
	// only use this on outer #...-positioner
	var digitalspeed_height =  0; // only needed later as result value
	var digitalspeed_width = 0;  // must be set when visible!
	var digitalspeed_top = 0;
	
	var displays_height = hscreen;
	var displays_width = screen_w;
	var displays_top = 0;
  	
 	//app.Debug('position screen: '+screen_w+'x'+hscreen);
 	
	// TODO: may be better more complicated "if" but fewer calculations!
	// - analog: never resize (until ZOOM is introduced) but influences displays
	// - digitalspeed: always scaleto y=free, depending on displays visible, only height at last
	// - displays visible: always scaleto y=free/auto, but dependend on width given by tacho
	
	// analog (only center or not)
				
	if(cssgauge_visible) {
		
		var gaugeleft = 0;
		if (isLandscape && displays.noneVisible()) {
			gaugeleft = (screen_w - $('#cssgauge-wrapper').outerWidth())/2;
		}
		$('#cssgauge-wrapper').css({
			'top':'0px',
			'left': gaugeleft+'px'
		});		
	}
	
	// digital (scale full or half)
	
	else if (displayDigitalspeed.isVisible()) {
		
		debugger;
		digitalspeed_width = screen_w;
		
		if (isLandscape && !displays.noneVisible()) {
			digitalspeed_width = screen_w / 2;
		}
		
		$('#digitalspeed-positioner').css({ // you can set with but not height to absolute
			'width':digitalspeed_width+'px'
		});

		// screen cannot be sooo stretched, that resize must depend on height in landscape mode
		// you can use scaleto (although it is called twice when displays visible) -> TODO:
		//TODO: also easier in object: before each scaleto, height must reset to 'auto'
		$('#digitalspeed-wrapper').css('height','auto');
		displays.scaleTo($('#digitalspeed-wrapper').width(),0); 
		
		// must be after scale
		digitalspeed_height = $('#digitalspeed-wrapper').outerHeight(true);
		//console.log(digitalspeed_height);
		// should always be reasonable value

		if(isLandscape) {
			digitalspeed_top = (hscreen - digitalspeed_height)/2;
		}
		
	}
	
	// displays-block

	if(!displays.noneVisible()) {
				
		$('#displays-wrapper').show();
		
		// width only cut in landscape
		if(isLandscape) {
			if(displayDigitalspeed.isVisible()) {
				displays_width -= digitalspeed_width;
			}
			else if (cssgauge_visible) {
				displays_width -= $('#cssgauge-wrapper').outerWidth(true); 		
			}
		}
		// and height in portrait
		else {
			if(displayDigitalspeed.isVisible()) {
				displays_top = digitalspeed_height;
			}
			else if (cssgauge_visible) {
				displays_top = $('#cssgauge-wrapper').outerHeight(true);
			}
			displays_height -= displays_top;
		}
				
		// left position and width
		// TODO: more calcs???
		$('#displays-positioner').css({
			'width':displays_width+'px',
			'left':screen_w-displays_width+'px'
		});
		
		// get offset  for layout (borders margin) depending on landscape
		var layoutoffset_x = $('#displays-positioner').width() - $('#displays-wrapper').width(); // TODO: make it *once* and save
		var layoutoffset_y = $('#displays-positioner').height() - $('#displays-wrapper').height(); // TODO: make it *once* and save
		//app.Debug('offsets:'+layoutoffset_x+'-'+layoutoffset_y);
		
		//TODO: also easier in object: before each scaleto, height must reset to 'auto'
		$('#displays-wrapper').css('height','auto');
		displays.scaleTo(displays_width-layoutoffset_x,0); // y:0 for receiving maximized heights 
		
		if (displays_height < $('#displays-wrapper').outerHeight(true)) { 
		 	app.Debug('try to scale smaller');
			displays.scaleTo(displays_width-layoutoffset_x,displays_height-layoutoffset_y); // not hspace but inner height due to layout of wrapper!!
		}
				
		// y center the scaled displays if not height > hscreen
	
		if (isLandscape) { // y center only in landscape now
			
			displays_height = $('#displays-wrapper').outerHeight(true); // must be taken after scaleTo !
			if (displays_height < hscreen) displays_top = (hscreen - displays_height) / 2;	
		}				
		
		// change vars to adjust digitalspeed-positioning
		
	} // displays visible
	else {
		// this is always when no displays seen:
		$('#displays-wrapper').hide();
	}
	
	
	// adjust vertical position + height of displays and digitalspeed
	// - height can be preset by scaleTo (but not manually/directly)
	// - top must not be set already
	 
	if (isLandscape && displayDigitalspeed.isVisible() && !displays.noneVisible()) {
			debugger;				

		// check which is larger!
		if(displays_height>digitalspeed_height) {				
			digitalspeed_height = $('#displays-wrapper').outerHeight(); // does work when both things have same layout
			digitalspeed_top = displays_top;
			
			displays_height = 'auto';
		}
		else {
			// displays set top to digitalspeed
			displays_top = digitalspeed_top;
			displays_height = $('#digitalspeed-wrapper').outerHeight(); // does work when both things have same layout
			digitalspeed_height= 'auto';
		}		
	}
	else { 
		// may be double // TODO: remove when else working
			displays_height = 'auto';
			digitalspeed_height = 'auto';		
	}
	
	// set top and height of digital + displays
	
	$('#digitalspeed-positioner').css({
		'top':digitalspeed_top+'px',
		'left':0                           // just to be sure
	});
	$('#digitalspeed-wrapper').css('height',digitalspeed_height); // ! height can also be string "auto"
		
	$('#displays-positioner').css({
		'top':displays_top+'px',
		'left':screen_w - displays_width +'px'
	});
	$('#displays-wrapper').css('height',displays_height); // ! height can also be string "auto"
	
}


/* central proc to save/restore the tacho range (persistent app settings).
  mode: "load" | "save" (if not set, performs load!)
  value: speed to be set (if "load", value is default in case load fails), if value not set or set to <=0, the CURRENT value will be taken if available
  return: -1 : error, else value which has been set
  
  ! save routine is inside gpstool.tachoRange
  
  TODO: check if it is possible that function runs before gpstool is defined!
*/
function resetTachoRange(mode,value) {
    
    // TODO: test change value
    
    if (mode=='save') {
        
        if (value && value>0) {
            gpstool.tachoRange(-value); // minus --> force set
        }
        else value=-1;
    }
    else {
        var c = app.LoadNumber(storage_tachorange,value);  // default==10, if no value found
        gpstool.tachoRange(-c); // neg. value -> force set    
    }

    return value;
}
    
 
// global vars
var displayHints = true;
/*
zählt bis 2 oder 3 (mit resize) um initApp() zu starten
10: init bereits ausgeführt */
var initCounter = 0;

    

/* vereint alle Programmstartfunktionen
(sinn siehe caller)
- returns: true: Code ausgeführt,
-          false: Code nicht ausgeführt
*/
function initApp()  {
	if (initCounter<3 || initCounter > 5) return false;
    
    // ONSTART
	   
    // init gauge before first scaleDisplays!
    gauge = new CssGauge( {
		'wrapper':'cssgauge-wrapper',
		'gauge':'cssgauge',
		'size':'auto', // not yet implemented !
		'maxRange':10,
		'majorStep':1, // must be < maxRange and reasonable adjusted
		'minorTicks':2, // should be between 0 and 5
		'overallAngle':270, // degrees, better < 340
		'value':0 // must be < max Range
	});

	// TODO: enable again:-> add to displays list
	$('#speedstats').hide();
	
	scaleDisplays(true); // must be before all the settings-dependend turn-offs of displays
	
	// init displays
	displays = new DisplayBoxList('geolocation');
	// save all in glob vars too
	// ! order of add must be order in HTML!
	displayDigitalspeed = displays.add('digitalspeed','--');// TODO: check whether object is rerefenced or copied!!!
	displayTime = displays.add('time');
	displayAltitude = displays.add('geoaltitude','--');
	displayLocation = displays.add('geolocation','--');

	// object referencing works (changes in displays.[one object] appear in references e.g. displayTime) 
	//var testobject = displays.get('time');
	//app.Debug('set new obj str: '+testobject.testString('thomas') );
	//app.Debug('check obj str in time: '+displayTime.testString() );
		    
    menustack = new PopupStack();
    settings = new AutoSettings(storage_settings); // string definiert Namen in localstorage // loads saved settings
    
    // TODO: layout_gauges sollte man evtl. auch mit einem stack steuern !!
    // TODO: oder integriert in display-objekt-verwaltung
    setTachoLayout();
	if (settings.get('tachoswitch')!='false') layout_gauges++;
	
    // this are the normal hints!
    if(settings.get('switchwarning')=='false')  {
        displayHints = false;
    }
    // this is the WARNING
    if(settings.get('switchredwarning')!='false')  {
    	menustack.push('warningdialog'); // note: all dialogs hidden by default!
    }
    if(settings.get('switchtime')=='false') displayTime.hide(); else { layout_gauges++; startClock(); }
    if(settings.get('switchposition')=='false') displayLocation.hide(); else layout_gauges++;
    if(settings.get('switchaltitude')=='false') displayAltitude.hide(); else layout_gauges++;
    if(settings.get('switchhudsettings')!='false') {
    	settings.switchit($('#switchhudsettings')); // auto saved will be overidden here
    }    

	// TODO: activate switcher when browser lang problem solved
	setLanguage(app.LoadText(kta.storage.language,'auto')); // auto bis einmal gesetzt, dann immer definiert
	//setLanguage('auto');
    
    // prevent accidently back 
    app.EnableBackKey( false );

    // EVENTS
	
	// TODO: events als letztes
    
    $('.ext-link').click(function() {
        var linktarget = $(this).attr("href");
        app.OpenUrl( linktarget );
        return false;
    });    
    
    $(".btn").on('tap',function() {
        
        resetMenuFade();
        
        var check = $(this).attr('href');
        //app.ShowPopup(check,"center");
        switch (check) {
            case '#exit' : Quit(); break;
            case '#cancel' : OnBack(); break; // TODO: test
            case '#settings' : OnMenu(); break; // TODO: check if can be started inside menus!! (Hope menus ly over :-)
            case '#info' :
                menustack.push('infocard');
                //app.ShowDebug(false);
                break;
			case '#warningcont' :
				// TODO: check if another menu COULD come in between!
				OnBack();
				break;
	        }
        
        return false;
    });
    

    $(".switcher").on('tap',function() {
    	resetMenuFade();
        var doPosition = false;
        var notfound = false;
        var check = $(this).attr('id');
        switch (check) {
            case 'tachoswitch' :
            	if(settings.get(check)=='false') {
            		layout_gauges ++;
            	}      
            	else layout_gauges --;
                settings.switchit(this);
                setTachoLayout();            	
                doPosition = true;
            	break;
            case 'digitalanalog':     	
            case 'digital' :
            case 'analog' :
            	settings.radio('.radio',this);
            	if(settings.get('tachoswitch')!='true') settings.switchit($('#tachoswitch')); // always activate tacho as well
                setTachoLayout();            	
                doPosition=true;
                break;
            case 'switchtime':
                if(settings.switchit(this)) {
                	displayTime.show();
                	layout_gauges++ ;
                	startClock();
                }
                else {
                	displayTime.hide();
                	layout_gauges--;
                	stopClock();
                }
                doPosition = true;
                break;
            case 'switchaltitude':
                
                if(settings.switchit(this)) {
                	displayAltitude.show();
                	layout_gauges++ ;
                }
                else {
                	displayAltitude.hide();
                	layout_gauges--;
                }
                doPosition = true;
                break;
            case 'switchposition':
                if(settings.switchit(this)) {
                	displayLocation.show();
                	layout_gauges++ ;
                }
                else {
                	displayLocation.hide();
	                layout_gauges--;
                } 
                doPosition = true;
                break;
            case 'switchhudsettings':
           		gpstool.switchHud();
                settings.switchit(this);
            	break;
            case 'switchwarning':
                if (settings.switchit(this)) {
                    displayHints = true;
	                showHint('All notes active','Alle Hinweise aktiviert.');
                }
                else {
                  showHint('All notes disabled','Alle Hinweise deaktiviert.');
				  displayHints = false;
				}  
                
                break;
            case 'switchredwarning':// TODO get new state as return so you can use it for switch reacting without the need of settings.get
                if(settings.switchit(this)) showHint('Warnings active','Warnhinweise wieder eingeschaltet.');
                else showHint('Warnings disabled','Warnhinweise ausgeschaltet.');
                break;                
            case 'switchautorange':
                resetTachoRange("save",10);  // current minimum
                showHint('Speedometer auto range reset','Auto-Bereich zurückgesetzt');
                //settings.switchit(this);
                break;
            default: notfound = true;
                break;
        }

        if (notfound) return true;
        else {
        	if(doPosition) positionDisplays();

	        // always (cases are checked inside functions)
			startGps();        
        	return false;
        }
    });
    
    // easy switch tacho layout:
	$('#tacho-container').click(function() {		
    	if(settings.get('tachoswitch')!='false') {
    		var next;
    		if (settings.get('digitalanalog')!='false') next = 'digital';
    		else if (settings.get('digital')!='false') next = 'analog';
    		else next = 'digitalanalog';
    			
	       	settings.radio('.radio',$('#'+next));
	        setTachoLayout();            	
	        positionDisplays();
	        switch(next) {
	        	case 'digitalanalog':showHint('tap again for Digital display','Erneut Tippen für Digital'); break;
	        	case 'digital': showHint('tap again for Analog display','Erneut Tippen für Analog'); break;
	        	case 'analog': showHint('tap again for both displays','Erneut Tippen für Digital + Analog'); break;
	        }
    	} 
	});

    // TODO: if id of button stored or can be derived from id of targeted dialog
    // --> you could automate this too
    
    $("#menubutton").click(function() {
        OnBack();
        return false;
    });
    $("#tachosettings").on('tap',function() {
        menustack.push('tachosettingsdialog');
        return false;
    });
    $("#moresettings").on('tap',function() {
        menustack.push('moresettingsdialog');
        return false;
    });
    $("#resetsettings").on('tap',function() {
        menustack.push('resetsettingsdialog');
        return false;
    });
    $("#showinfo").on('tap',function() {
        menustack.push('infocard');
        return false;
    });
    // TODO: alle, die "Direct options" sind in einen Block - ggf. class!
    $(".switchlocformat").click(function() {
        if(gpstool.switchLocFormat()=='decimal') 
        	showHint('tap again for degree values','tippen für Grad-Anzeige');
        else showHint('tap again for decimal values','tippen für Dezimal-Anzeige');
        //gpstool.switchHud('off');        
        return false;
    });
    // yes no on back
    $('#yes').on('tap',function() {
        Quit();
        return false;
    });
    $('#no').on('tap',function() {
        $('#yesnodialog').hide(); // TODO: use menustack, but then u must start it with menustack too
        return false;
    });
    $('#setlanguage').on('tap',function() {
    	if (kta.language=='de') {
    		setLanguage('en');
    		showHint ('tap again for German');
    	}
    	else {
    		setLanguage('de');
    		showHint ('Erneut tippen für Englisch');    		
    	}
    	app.SaveText(kta.storage.language,kta.language); // new val already in kta.language
        return false;
    });

 
   
	//Zeug von OnStart:
	

    //settings.init('backkey',true); // init bewirkt, dass true nur gesetzt wird, wenn es nicht geladen werden konnte
    // init ist meist nicht nötig, wenn im html der gewünschte Anfangsstatus gesetzt ist
    
    // menu for exit instead of back a
    // TODO: what happens on tablets??
    //app.SetMenu( "Einstellungen,Beenden" );

    tablet = app.IsTablet(); // returns boolean
    
    gpstool = new GpsTools(); //global var speed now named: gpstool
   
    //Create and start location sensor. 
    //(Achievable update rate is hardware specific) 
    loc = app.CreateLocator( "GPS,Network" ); 
    loc.SetOnChange( loc_OnChange );  // you cannot directly set to member of gpstool :-(
    loc.SetRate( 1 ); //seconds (refresh data), test lower rate! good for background activity!
    startGps(); // never do loc.Start(); alone --> use this wrapper  
    
    
    // TODO: do also inside gpstoool
    // ! now always load (no switching) !
	resetTachoRange("load",10); // default==10, if no value found
    
    //if(settings.get('switchautorange')=='false') {
    //    resetTachoRange("save",tacho_defaultrange);
    //}
    //else {
      //  resetTachoRange("load",10); // default==10, if no value found
    //}

    // TODO: show when settings ready:
    $('#geobearing,#geoaccuracy').hide();
    
    // TODO: hier auch scaleDisplays(), besonders für Landscape
    positionDisplays(); // warum geht nicht? - timing problem??
    setGpsWarning(); // display warnings until gps works 
    
    
    $('#splashscreen').hide(); // TODO: größer wegen fullscreen kurz nach init
    
    app.Debug('num gauges:'+layout_gauges);
    resetHud();
    resetMenuFade();

	// mechanism to handle the case you don't know whether 
    // OnStart or document ready comes first:
	initCounter = 100;
	return true;	
} // initApp


function OnStart() {
	//app.SetDebugEnabled( false ); // check if app.Debug calls cause error (use wrapper function!)
	//mydebug = app.CreateDebug();
	//app.ShowDebug(true);
	
	app.Debug("onStart");
    //app.SetScreenMode( "Full"); // TODO: probleme mit Schriftgrößen und Tap-Events 
    app.PreventScreenLock(true);

	if (app_browsermode==true) app.Debug('browser mode');
	
    // frage ob gerade landscape, dann init erst bei resize:
    // TODO: ungünstig formatierte Inhalte leider kurz zu sehen bevor resize kommt.
    // TODO: teste ob code wieder aktiviert werden muss, wenn landscape/portrait als fest gespeichert werden  
	//if (app.GetOrientation()=="Landscape") {
	//initCounter++; // causes init to be done on resize
	//}
	//else
		initCounter+=2; 
	
	// force portrait until layout is more flexible:
	//app.SetOrientation( "Portrait" ); 
	// für lock -> bekommt man halt entweder primary portrait oder primary landscape
        	
	initApp();
}


$(document).ready(function() {

	app.Debug('document ready');
    initCounter++;
	initApp();
	
	 // more reliable than onconfig ! :-)
	 $(window).resize(function() {
        // TODO: only if really needed: 
        //      handle problem with possible multiple trigger resize events in some cases
        
        // TODO: warum reagiert nicht, wenn Statusbar des Gerätes weg ??
        // TODO: teste ob OnConfig bei Statusbar-weg reagiert !
        app.Debug("on window resize");
		initCounter++;
		if (initApp()==false) {
            // resize after init
    		scaleDisplays(false);
    		//ORI scaleDisplays(); // wenn später korrekt arbeitet, dürfte doppelter Aufruf egal sein!!
    		positionDisplays();
		}
    });
    
});

// verwende source id : de.kuehne_webdienste.kwdtacho
	
</script>   
</body>
</html> 