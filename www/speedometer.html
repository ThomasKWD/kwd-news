<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8">
    <meta name="charset" content="utf-8">

    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">

    <title>Tachometer App Android DroidScript</title>
    
    <link rel="stylesheet" href="css/fontello.css">
    <link rel="stylesheet" href="css/cssgauge.css">
  
    <script src='file:///android_asset/app.js'></script>
	    <script src='js/droidscript.js'></script>
    
    <script src="js/cssgauge.js"></script>

<!--
	WARNING! This is the *high speed* version - without jQuery. It may not work on old devices!
	 
	this code is freely copyable between browser/phonegap/DroidScript -->
<!--
	
	NOTES:
	
	- jQuery free version
	
	
	TODO: for this release
	
	- INTERNAL
		- alle sicherheits-'if' weg, wenn fehlschlagen nur von meinen Inputs abhängt, also z.B. nicht vom Gerät/Umgebung
		-> im Zweifel mehr throws
		- suche Stellen wo css größen ohne px gesetzt -> Probleme!
		- verwende auch classList.toggle!
		- kein 'absolute' Element sollte 'margin' haben (verwirrt nur), für Abstände kann der äußere 'padding' haben
		- bei fehlern displays verwende getComputedStyle! + versuche scrollLeft property!
		- bei weiter Fehlern: neue Ideen der Umsetzung anstatt einfach jQuery-Ansatz übertragen!
		
		- es scheint wirklich möglich zu sein, in DOM-Objekten zusäzliche Daten zwischen zu speichern !! :-)
    
	- LANDSCAPE
		- evtl. landscape displays wrapper vergrößern, wenn analog
		- position Fehler nach hud korrigieren checke Größen nach resize!
		  (evtl. gleiches Problem wie bei menu: reagiert nicht beim ersten mal
		  prüfe auch wieviele resize-Events!)
		
	TODO: for next release:

	- HUD
	- ZOOM
		- zoom analog soll ratio berechnen und den angezeigten Winkel davon abhängig machen
	- zoom could mean don't use positionDisplays and don't shrink analog on quadratic displays
	- more direct options
	- skin minimal
	
	- EMULATOR: simuliere Statusbar und ihr wegschalten (Problem: screen größe
        - screen größe grundsätzlich mit droidscript Funktionen 
        statt reinen webview Variablen, testen!	
	
	- .skin-hud von skin-minimal trennen (nur ähnlich)
	- nachtmodus oder wenigstens minimal skan manuell verfügbar machen
	
	TODO: nach nächstem Release:

    - PORTRAIT
        - wieder zentrieren wie früher
	- bei landscape immer Menüs/Cards zweigeteilt nebeneinander (innen float Blöcke ähnlich bootstrap)
	    - aber Abfrage auf sehr kompakte displays (Quadrate)
    
	- was tun bei sehr quadrat-nahen Bildschirmen? -- evtl. analog Tacho kleiner - oder einige displays verbergen 
	andere nicht zu klein werden lassen (Problem tritt bei nur-digital nicht auf)
	- Treshhold als ratio w/h einfach im Browser ausprobieren 
	- untere Ecken von displays-wrapper nicht rund und Rand außerhalb
	
	LAYOUT: 
	- css reduziert und background-color(!) wenn OSVersion < 14 (teste Sebi Handy)
	- menüs zweispaltig, mit internem scroll, evtl. rand weg oder außerhalb des screens positionieren bei sehr kleinen displays
	 - zweispaltig nicht bei sehr großen displays oder wenn menüs klein genug!
	- HINTS: bei großen Bildschirmen evtl. Hints als Fenster rechts, oder zusäzliche ausführliche Hints rechts, die bei
	  kleinen Screens als Fragezeichen mit selbst zu öffnendem popup erscheinen	
	 
	TODO:
	
	Infocard:
	- in 2 oder mehr Blöcke unterteilen, die bei großen Displays (Landscape oder immer) nebeneinander gestellt werden.
	  (oder von vorherein float responsive)
	
	Ideen:
	- Schnellumschaltungen "1-touch" (abschaltbar)
	- Skins: Standard, Minimal, Auto(=Tag/Nacht)
	-GPS-Warnung Balken unten auch bei GPS an mit Farben (je nach Range) 
	
	- glob Variablen oder array für sichtbarkeit von Komponenten spart zeitaufwendiges u. manchmal 
	  fehleranfälliges (wegen Dauer) abfragen über jQuery
	  besonders für das häufige Abfragen innerhal gpstool.change

	- vordefinierte Verschachtelung für displays:
		- wenn drei, die 2 kürzesten nebeneinander, das lange darunter
		- wenn vier, die beiden langen auf eine Seite??
		- wenn 2 immer untereinander	  
		- gilt für landscape ohne gauge und portrait unter gauge
		- Länge wird im Objekt bei init gespeichert, genau wie der init-string
	- bei Tablet Menüs (immer rechts und )immer 90% Höhe und *immer extra Fenster mit Hinweisen*
	- Tablet Menüs evtl. auch Untermenüs rechts von Hauptmenüs (grundsätzlich Platz für drei Menüs nebeneinander, bei Portrait 2)
	  - Hilfedialog zuschaltbar (abh. vo Hinweise??)- auch bei phones/portrait (hier Breite des normalen Menüs abh. von *Höhe* in Landsacpe damit nict so breit aussieht...)
	- im menu einstellbar ob max unt mittel im Hintergrund genommen werden, wenn Tacho aus (dann könnte man ggf. GPS
	  abschalten, wenn Uhr alleine sichtbar)
	
	- BEENDEN bei Landscape möglichst immer sichtbar (einfach nach oben?)
	
	TODO: emulator: position des browsers nehmen + network
-->


    <style>
        /* #83C2FD */
        /* #DD0000 warning */
         
        * {box-sizing:border-box;font-family:Tahoma,Verdana,Univers,sans-serif;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
        }
        /* note: select/callout should be activated in input fields or longer texts
        */
        body { margin:0;padding:0;font-size:15px;color:white;background-color:black;}
        body.en :lang(de) { display:none; }
        body.de :lang(en) { display:none; }
        p,h1,h2,h3,h4 {margin:0;padding:0;color:white;}
       html { height: 100%; } body { min-height: 100%; }
        .hgchange {
        	opacity:0.0;
              }
		#hg {
    		position:fixed;
    		top:0;
    		left:0;
    		width:100%;
    		height:100%;
    		/* JS must reset me to real height */
    		background-color:#83C2FD;
    		transition:1.5s opacity ease-in;
		}
		/* for debugging and testing: */
		#ruler {
			position:fixed;
			width:0;
			height:100%;
			top:0;
			left:300px;
			border-top:1px solid red;
			border-left:1px solid blue;
			z-index:10000;
			display:none;
		}
		/* links and menus */
		a,a:hover,a:focus,a:active,a:visited {
	         -webkit-tap-highlight-color: rgba(255,255,255,0);
		}   
        .ext-btn,
        .btn {
            display:block;
            color:white !important;
            font-size:130%;
            font-weight:bold;
            background-color:#888;
            padding:5px;
            margin:1em;
            border:4px solid #f0f0f0;
            border-radius:15px;
            box-shadow:3px 3px 10px #ddd inset,-3px -3px 7px #555 inset;
            text-decoration:none;
            text-align:center;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
        }
        /* want colors of KWD Logo */
        .ext-btn { 
        	background-color:#83C2FD;
        	border-color:#DF3F2E;
            box-shadow:3px 3px 10px #eee inset,-3px -3px 7px #444 inset;
        }
        /*  switcher must not have .btn
            can have class "switched-on" to determine state
        */
        a.back-arrow,
        a.back-arrow:link,
        a.back-arrow:visited,
        a.back-arrow:hover,
        a.back-arrow:focus,
        a.back-arrow:active {
       		color:white;
       		display:inline-block;
       		margin-left:-0.25em;
       		margin-right:0.75em;
       		text-decoration: none;
       	}
       	
        a.switcher,
        a.switcher:link,
        a.switcher:visited,
        a.switcher:hover,
        a.switcher:focus,
        a.switcher:active {
            display:block;
            color:white;
            padding:1em 1em 1em 1em;
            /*padding:1em 1em 1em 3em;
             text-indent:-1.5em;*/
            margin:0;
            border-top:1px solid white;
            text-decoration:none;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
        }
       
        .lastswitcher {
            border-bottom:1px solid white;
        }
        .fa,
        .fa-black {
            display:inline-block;
            width:40px;
            padding-right:20px;
        }
        .switcher .fa {
            color:#dd0000;
        }        
        .switcher .fa-black {
        	color:#000000;
        }
        .switched-on .fa,
        .switched-on .fa-black {
			color :#00dd00;
		}
		.menuitem .fa
		{
            color:#FFFFFF;
        }
		.mirror {
		    -webkit-transform:scale(-1,1);
			transform:scale(-1,1);
            padding-right:0;
            padding-left:1em;
            text-align:right;
		}
		.icon-zoom-out {
			font-size:65%;
		}
        .text-icon {
        	font-size:65%;
        }
		/* marks elements to be changed when no-gps
		 */
		.gps {
		}
		.no-gps {
			color:#dd0000 !important;
		}
        /* some properties are set by JS */
        #digital-on-analog {
            position:absolute;
            letter-spacing:0;
            padding-left:0 !important;
            padding-right:0 !important;
        }

        #info-on-analog {
            position:absolute;
            color:white;
            line-height:1em;
            text-align:center;
            font-weight:bold;
        }
        .gps-warning {
        	color:#DD0000;
        }
        .gps-warning-text {
        	font-size:1.75em;
        	line-height:1em;
        }
        /* text inside #digital-on-analog shield */
        #dona-text {
            position:absolute;
            letter-spacing:0;                      
        }
        /* for object-driven layout: */
       /* ! no padding-bottom since font height leads to space anyway */ 
       .display-box {
			position:relative;
			overflow:hidden;
            font-size:100px;
            line-height:1em;
            font-weight:bold;
			padding:5px 15px 0 15px;
			white-space:nowrap;
			text-align:center;
			top:0;
			left:0;  
			border-top:1px solid #ddd;       	
       }
      .first-display {
       		border-top-color:transparent;
       		margin-top:0;
       }
		.positioner {
			position:absolute;
		}
		/* alle displays scrollen nicht! */
		#display-container {
			width:100%;
			height:100%;
			overflow:hidden;
			position:fixed;
		}
		#displays-positioner {
			/*outline: 1px solid green;*/
		}
		#digitalspeed-positioner {
			/*outline: 1px solid yellow;*/ 
		}
		/* not yet defined!: */
		#analogspeed-positioner {
			/*outline: 1px solid red;*/
 		}
 		#cssgauge-wrapper {
 			/*outline:1px solid orange;*/
 		}
        #displays-wrapper {
        	margin-top:10px;
        }
        #tacho-container {
        	position:absolute;
        }
		#digitalspeed-wrapper {
			position:relative;
		}
		#tacho-container {
			/*outline:1px solid red;*/
		}        
		.display-text, .display-text * {
			white-space: nowrap;
		}
        #seconds-text {
        	font-size:50%;
        }
        .halfsize {
        	background-color: #000000;
        }
        #maxspeed {
        	float:right;
        }
        #averagespeed {
			float:left; 	
        }
        .speed {
            line-height:1.25em;
        }
        .valuefract {
        	font-size:65%;
        }
        /* kmh wird jetzt unabhängig gesetzt, da es bei analog die Anzeige
        von canvgauge verdeckt.
        wenn digital, soll es allerdings innerhalb positioniert werden.
        Alternative: zwei verschiedene 
        
        TODO: Schriftgrößen aller digitalen Anzeigen inkl. .unitlabel
            in Funktion gleichwertig verarbeiten!
            
        */
        .unitlabel {
            position:absolute;
            color:white;
            line-height:2rem;
            text-align:center;
            font-weight:normal;
            padding:10px;
            font-size:0.9rem;
            right:0;
            bottom:0;        
        }
        #gauge {
            /*
                  transform:scale(-1,1);
          -moz-transform:scaleX(-1);
          -webkit-transform: scaleX(-1);
          */
        }
        #title {
            position:relative;
            bottom:1em;
            padding:1em;
        }
        #logo img {
            width:100%;
            margin-left:-7px;
            margin-bottom:15px;
        }
        #title p{
            margin-bottom:5px;
        }
       	#dialogs-blender {
       		background-color:rgba(255,255,255,0.7);
       		width:100%;
       		height:100%;
       		position:fixed;
       		overflow:hidden;
       		display:none;
       	}
        /* for current control funcs. all dialogs must be visible! */
        .dialog,
		#displays-wrapper,
		#digitalspeed-wrapper {
            color:white;
            /*box-shadow: 5px 5px 10px #000 inset,5px 5px 20px #000;*/
           	background-color:black;
            border:10px solid #ddd;
            border-radius:3em;
            font-size:1em;
        }
		#displays-wrapper,
		#digitalspeed-wrapper {
			margin:10px;			
		}
        #displays-wrapper {
        	position: relative;
        }
		.dialog {
			position:absolute;
			left:5px;
			top:5px;
			display:block;
	        width:90%;
	        max-width:30em;
	        /* das verursacht leider bad performance element scroll: max-height:95%; */
			background-color:black;
			overflow:auto;
			display:none;
		 }
		 /* TODO: du brauchst einen inneren div, damit wichtige Buttons nicht mitscrollen! */
        .dialog p,
        .dialog h1,
        .dialog h2,
        .dialog h3 {
            margin:1em;
        }
        #menu {
            margin: 1em auto;
            text-align:center;
            display:none;
        }
        #warningdialog {
            color:white;
            border-color:#CC0000;
        }
        #warningdialog h3 {
            color:red;
            text-align:center;
        }
        #warningdialog p {
        	font-weight:bold;
        }
        #splashscreen {
        	display:table;
            background-color: #83C2FD;
            position:absolute;
            top:0;
            left:0;
            width:100%;
            height:100%;
        	padding:20px;
        }
        #splashscreen p {
        	display:table-cell;
        	vertical-align:middle;
            font-weight:bold;
            text-align:center;
        }
        #splashscreen img {
            width:100%;
            max-width:360px;
        }
        #wait {
            width:200px;
            height:2em;
            margin:auto;
        }
        #infocard {
            position:absolute;
            top:0;
            width:100%;
            min-height:100%;
            overflow:scroll;
            background-color:white;
            color:black;
            padding:25px;
            display:none;
        }
        #infocard * {
            color:black;
        }
        #infocard p,
        #infocard h1,
        #infocard h2,
        #infocard h3 {
            margin-bottom: 0.7em;
        }
        #infocard h3{
            font-size:1em;
        }
        #infocard a {
            font-weight:bold;
            color:  #40a1fc;
        }
        /* neg right padding due to css of .fa : */
        #menubutton {
            position:absolute;
            top:0;
            right:0;
            font-size:2em;
            padding:0.5em 0em 1em 1em;
            margin: 0 -0.25em 0 0;
        }
        #gpswarning {
            position:absolute;
            top:0;
            left:0;
            font-size:15px;
            font-weight:bold;
            color:#ff2222;
            color:white;
            padding:0.3em;
            background-color: rgba(0,0,0,0.6);
            border-right:3px solid #aa0000;
            border-bottom:3px solid #aa0000;
            border-bottom-right-radius: 10px;
        }
        .toastmessage {
		    width:80%;
		    height:auto;
		    position:fixed;
		    left:50%;
		    margin-left:-40%;
		    bottom:10px;
		    background-color: #383838;
		    color: #F0F0F0;
		    font-family: Calibri,sans-serif;
		    font-size: 20px;
		    padding:10px;
		    text-align:center;
		    border-radius: 2px;
		    -webkit-box-shadow: 0px 0px 24px -1px rgba(56, 56, 56, 1);
		    -moz-box-shadow: 0px 0px 24px -1px rgba(56, 56, 56, 1);
		    box-shadow: 0px 0px 24px -1px rgba(56, 56, 56, 1);
		    display:none;
		}
		
		/* class for changes when digital + analog */
		.dona  .g-center {
			background-color:black !important;
		}
		.dona .g-pointer {
			border-bottom-width: 85px !important;
			border-left-width:8px !important;
			border-right-width:8px !important;
		}

		/* 
		für Skins addClass mit verschachtelten Klassen,
		*/
		
		
		/* skin-plastic */
		/* is default skin but not enabled in old versions */
		.dialog.skin-plastic {
			background-color:transparent;
   			box-shadow: 5px 5px 20px #000;
		}
		.dialog.skin-plastic,
		#displays-wrapper.skin-plastic,
		#digitalspeed-wrapper.skin-plastic {
            background-image:-webkit-linear-gradient(top,rgba(100,100,100,0.95) 5%, rgba(0,0,0,0.95) 40%);
            background-image:linear-gradient(rgba(100,100,100,0.95) 5%, rgba(0,0,0,0.95) 40%);            
            -webkit-box-shadow: 5px 5px 10px #000 inset;			
            box-shadow: 5px 5px 10px #000 inset;			
		}
		
		/* skin-minimal */  
		/* TODO: skin class only in wrapper
		 * TODO: .g-pointer shorter in .skin-minimal
		 */
		.gauge.skin-minimal {
			background-image: none;
			border-color:black;
		}
		.skin-minimal .g-center {
			background-color:black;
		}
		.skin-minimal .g-pointer {
			border-bottom-width: 130px;
		}
		.gauge.skin-minimal .g-minor,
		.gauge.skin-minimal .g-majortick {
			background-color:white;
		}
		.display-box.skin-minimal {
			border-color:transparent;
			background-color:black;
		}
		#digital-on-analog.skin-minimal {
			border-top-color: black;
		}
		#digitalspeed-wrapper.skin-minimal,
		#displays-wrapper.skin-minimal {
			background-image:none;
			border-color:black;
			box-shadow:none;
			border-radius:0;
		}
		/*
		TODO: Unterscheidung .hud-able .hud (letztere wird erst hinzugefügt, wenn hud aktiviert)
		*/
    </style>
</head>

<body onload="app.Start()">

<div id="hg"></div>

<div id="touch-wrapper">
	
<div id="display-container">
    <div id="tacho-container" class="fast-option">
  
        <div id="cssgauge-wrapper">
			<div id="cssgauge" class="gauge skin">
				<div class="g-scale"></div>
					<div id="g-ticks-container" class="g-item"></div>
					<div id="g-pointer" class="g-pointer g-item"></div>
					<div id="g-center" class="g-center g-item"></div>
	            <div id="digital-on-analog" class="hud skin display-box"><div id="dona-text" class="speed gps display-text">0000</div></div>
	            <div id="info-on-analog"><div id="dona-tachounit" class="tachounit fast-option gps-no-warning">kmh/h</div><div class="gps-warning"><span class="gps-warning-text">GPS</span></div></div>
			</div>
		</div>
<!--        <div id="speedstats">
            <div id="averagespeed" class="display-box hud halfsize test"><span id="averagespeedtext" class="display-text gps">00000</span><div id="averagespeedlabel" class="unitlabel">&#216;</div></div>
            <div id="maxspeed" class="display-box hud halfsize test"><span id="maxspeedtext" class="display-text gps">00000</span><div id="maxspeedlabel" class="unitlabel">max</div></div>
        </div>
-->
		<div id="digitalspeed-positioner" class="positioner">
			<div id="digitalspeed-wrapper" class="skin"><div id="digitalspeed" class="hud skin display-box"><span class="speed display-text gps">0000</span><div id="kmh-digital" class="unitlabel autofade tachounit fast-option">km/h</div></div></div>
		</div>
		
		<!--you will need 2 versions for display in digital OR analog
			TODO: make flag instead of setting both (performance)
		-->
		
	</div><!--tacho-container-->

	<div id="displays-positioner" class="positioner">
    
    <div id="displays-wrapper" class="skin">    	
	    <div id="time" class="hud display-box skin fast-option"><span id="time-text-wrapper" class="display-text"><span id="time-text">00:00</span><span id="seconds-text">:00</span></span></div>
	    <div id="geoaltitude" class="hud display-box skin"><span id="altitudetext" class="display-text gps">00000</span><div id="m-alt" class="unitlabel autofade altitudeunit fast-option">m</div> </div>
		<div id="geolocation" class="hud display-box skin fast-option"><span id="positiontext" class="display-text gps">00°00'00.0"N<br />00°00'00.0"E</span></div>

<!--        <div id="averagespeed" class="display-box hud halfsize test"><span id="averagespeedtext" class="display-text gps">00000</span><div id="averagespeedlabel" class="unitlabel">&#216;</div></div>
        <div id="maxspeed" class="display-box hud halfsize test"><span id="maxspeedtext" class="display-text gps">00000</span><div id="maxspeedlabel" class="unitlabel">max</div></div>
-->    </div>
   </div>
	
</div>
<!--        <div id="geobearing" class="hud display-frame"><span id="bearingtext skin" class="display-text gps">000°</span><div id="bearinginfo" class="unitlabel">Sensor</div></div>
        <div id="geoaccuracy" class="hud display-frame"><span id="accuracytext skin" class="display-text gps">0000</span><div id="accuracyinfo" class="unitlabel">m</div></div>
-->

<div id="dialogs-blender"></div>

    <div id="menu">
        <a class="btn" href="#info">Info</a>
        <a class="btn" href="#settings">Einstellungen / Settings</a>
    </div>
    
    <div id="infocard" class="card">
        <h2><a href="#back" class="back-arrow ext-link"><span class="icon-left-big"></span></a><span lang="de">Viel Spaß mit unserer Tacho- und GPS-App!</span><span lang="en">Welcome to this Speedometer and GPS Tool</span></h2>
		<p>by</p>
		<a id="logo" href="#"><img src="res/kwd-4-title.png" /></a>
		<p lang="de">Dies ist ein <strong>GPS</strong>-Tachometer mit Höhen-, Positions- und Zeitanzeige für Reise und Freizeit.</p>
		<p lang="en">Use this GPS speedometer with altitude, geolocation and current time, especially when you are not driving
			 a car but going by bicycle, by train, by boat or even by airplane!</p>
	  	
	    <p lang="de">Die aktuelle GPS-Position <!--oder Ihre Richtung --> schnell anzuzeigen ist in der freien Natur nicht nur interessant sondern z.B. auch im
        Notfall eine wichtige Info für Rettungskräfte. Es kann wahlweise der dezimale Wert angezeigt werden.</p>
        <p lang="en">Sometimes it is useful or even essential to display the current geoloation quickly
          - even without a network connection -  	e.g. in an emergency.</p>
        
        <p lang="de"><b>Die Genauigkeit</b> der Höhenangabe über NN sollte nicht überschätzt werden.
        Sie liegt im gleichen Bereich wie die der Position, wo die Ungenauigkeit
        selbst bei guten Empfang meist zwischen 3 und 20 Metern schwankt (bei schlechtem Empfang bis über 100 Meter).
        Ähnliches gilt für die Geschwindigkeit bei sehr geringen Werten.</p>
        
        <p lang="en">Note that sometimes the <b>accuracy</b> seems very low when observing the altitude (above sea level) since it will be the same as 
        	the accuracy of location. While you expect the location to differ for several meters, it looks odd in terms of altitude
        	when there is in error of 3m or even 50 m (depending on GPS signal). This also applies to very low speed values.</p> 
        	 
        
        <p lang="de">Ihr Gerät benötigt einen <b>GPS-Sensor</b> für die Geschwindigkeit. Netzempfang ist jedoch nicht nötig.
        	Die App kann auch im "Flugmodus" laufen.
        	Bitte beachten Sie, dass Sie  eventuell erst GPS (meist "Standort > Hohe Genauigkeit" genannt) in den Einstellungen
        Ihres Gerätes aktivieren müssen.</p>
        <p lang="en">Your device must have a <b>GPS-sensor</b> enabled to display speed (see under 'Location' in the device's
        	settings). You don't need a network connection and can also use the app in "flight mode". 
        
      	<p lang="de"> <b>Die HUD-Funktion</b>
        ("Head-Up-Display") erlaubt es, das Gerät mit gespiegelter Anzeige vor die Scheibe eines Fahrzeugs zu legen. (Beachten Sie bitte,
        dass es in einigen Ländern/Gebieten möglicherweise nicht gestattet ist, ein nicht fest verbautes HUD im Straßenverkehr zu nutzen!)</p>
        <p lang="en">With <b>"HUD" (head up display)</b> turned on you can put your device in front of mirroring glass (of an vehicle) to read the 
        	reflected displays. Note that the brightness of your device ist not high enough for daylight use in most cases.</p>
        
<!--
	        <p lang="de">Die Einstellung "<b>Direktauswahl</b>" erlaubt die Änderung einiger Einstellungen, wenn Sie einfach auf die Anzeigen tippen.
        	Diese Funktion kann abgeschaltet werden.</p>
        <p lang="en">The option "Direct Config" means you can change some settings by tapping the gauges and values. You can turn of this option in the settings menu.</p>
-->    
        <p lang="de">Standortdaten werden von dieser App nicht gespeichert, gesendet  oder anders weitergegeben.</p>
        <p lang="en">Geo location data are not stored, send or shared in any way by this app.</p>
        <p lang="de"><a class="ext-link" href="http://kuehne-webdienste.de/index.php?article_id=47">Datenschutzerklärung</a></p>
        <p lang="en"><a class="ext-link" href="http://kuehne-webdienste.de/index.php?article_id=52">Privacy policy</a></p>
        
        <p>KWD Tacho Version <span id="appversion"></span> <span id="internalinfo"> </span> &copy; 2015 <a class="ext-link" href="http://kuehne-webdienste.de/">KUEHNE-Webdienste.de</a></p>
        <p lang="de"><a lang="de" class="ext-link" href="http://kuehne-webdienste.de/index.php?article_id=49">Lizenzen</a></p>
        <p lang="en"><a lang="en" class="ext-link" href="http://kuehne-webdienste.de/index.php?article_id=51">Licenses</a></p>
        
        <p lang="de">Diese App verzichtet auf Werbe-Einblendungen und ist dennoch kostenlos.
        Falls Ihnen die App gefällt, können Sie ihre Entwicklung voran treiben,
        indem Sie einen kleinen Betrag spenden. Vielen Dank!
        
        <a id="donate-button" href="http://kuehne-webdienste.de/index.php?article_id=50" class="ext-btn ext-link"><span lang="de">Spenden</span></a>
        
        </p>

    </div>

<!--wraps all dialogs: -->
<div id="dialogs-wrapper">

    <div id="title" class="autofade">
        
	  <p id="no-gauges"><a class="btn" href="#settings"><span lang="en">Add meters</span><span lang="de">Anzeigen zuschalten</span></a></p>
	  
  	</div>



  <div id="warningdialog" class="dialog skin">
    <h3 lang="de">Warnung!</h3>
    <h3 lang="en">Warning!</h3>
    
    <p  lang="de">Verwendung auf eigene Gefahr!</p>
    <p  lang="en">Use this app at your own risk!</p>
    
    <p lang="en">Opening or controlling the app while driving or using a machine is dangerous! Start this app before you start driving or working!</p>
    	<p lang="de">Bedienen Sie diese App nicht,
      während Sie ein Fahrzeug oder eine Maschine steuern! Starten Sie die App vor Beginn der Fahrt/Tätigkeit!</p>
      
    <p lang="en">The use of the HUD (projecting the display on to a windscreen of a vehicle)  in traffic may be prohibited by law in your country, state or location.</p>

    <p lang="en">The display timeout of your device is disabled. Don't leave the device unattended!</p>
    <p lang="de"> Der Anzeige-Timeout Ihres Gerätes ist deaktiviert.
      Lassen Sie die App nicht unbeaufsichtigt laufen!</p>
      
	<p><a href="#warningcont" class="btn"><span lang="de">Weiter</span><span lang="en">Continue</span></a></p>
  </div>

	<div id="newsdialog" class="dialog skin">
		<h3><span lang="en">News</span><span lang="de">Neu</span></h3>

		<p lang="en">Now you can change units of measure (km/h, mph, m/s, kn - for altitude m, ft) directly by touching the unit text. You can also change the type of speedometer directly.
			You can turn off these "One touch settings" in the settings.</p>
		<p lang="de">Tachometertyp und Einheiten können direkt auf den Anzeigen umgeschaltet werden. Tippen Sie auf den Tacho oder die Einheitenangabe. Dies kann in den Einstellungen auch ausgeschaltet werden unter "Schnellauswahl".</p>
	<p><a href="#warningcont" class="btn"><span lang="de">Weiter</span><span lang="en">Continue</span></a></p>
		<a id="switchnews1" class="switcher" href="#"><span class="fa-black icon-ok"></span><span lang="de">Nicht mehr anzeigen</span><span lang="en">Don't show again</span></a>				
	</div>
	
    <div id="settingsdialog" class="dialog skin">
        <h3><span lang="de">Auswahl</span><span lang="en">Options</span></h3>

      <a id="tachoswitch" class="switcher switched-on" href="#"><span class="fa icon-gauge"></span><span lang="de">Tachometer</span><span lang="en">Speedometer</span></a>
	  <a id="switchtime" class="switcher switched-on" href="#"><span class="fa icon-clock"></span><span lang="de">Uhrzeit</span><span lang="en">Time</span></a>
	  <a id="switchaltitude" class="switcher switched-on" href="#"><span class="fa icon-zoom-out icon-android-landscape-512px"></span><span lang="en">Altitude</span><span lang="de">Höhe</span></a>
	  <a id="switchposition" class="switcher switched-on" href="#"><span class="fa icon-location"></span><span lang="en">Geo-location</span><span lang="de">Position</span></a>
	  <a id="switchhudsettings" class="switcher" href="#"><span class="fa icon-sort-numeric mirror"></span>HUD</a>
      <a id="moresettings" class="switcher menuitem" href="#"><span class="fa icon-cog"></span><span lang="en">Settings</span><span lang="de">Einstellungen</span></a>
	  <a id="showinfo" class="switcher menuitem" href="#"><span class="fa icon-info-circled"></span>Info</a>
	  <!--<a id="switchbackkey" class="switcher switched-on" href="#"><span class="fa icon-ok"></span> Beenden mit Zurück-Taste</a>-->
	  

        <!--<a class="btn" href="#info">Info</a>-->
        <a class="btn" href="#exit"><span lang="en">EXIT APP</span><span lang="de">APP BEENDEN</span></a>
        <!--<a class="btn" href="#cancel">Abbrechen</a>-->
    </div>
    
    <div id="tachosettingsdialog" class="dialog sub-dialog skin">
        <h3><span lang="en">Speedometer</span><span lang="de">Tachometer</span></h3>

	      <a id="digitalanalog" class="switcher switched-on radio" href="#"><span class="fa icon-gauge-2"></span>Digital + Analog</a>
	      <a id="digital" class="switcher radio" href="#"><span class="fa icon-sort-numeric"></span><span lang="de">Nur </span>Digital<span lang="en"> only</span></a>
		  <a id="analog" class="switcher radio" href="#"><span class="fa icon-gauge"></span><span lang="de">Nur </span>Analog<span lang="en"> only</span></a>
		  <a id="switchunits" class="switcher menuitem" href="#"><span class="fa icon-cog"></span><span lang="de">Maßeinheit</span><span lang="en">Units</span> (<span class="tachounit">km/h</span>)</a> 
	       <a id="resetmaxspeed" class="switcher menuitem" href="#"><span class="fa text-icon">MAX</span><span lang="de">Max. Geschwindigkeit löschen</span><span lang="en">Reset max speed</span></a>	  
	       <a id="resetaveragespeed" class="switcher menuitem" href="#"><span class="fa text-icon">AVR</span><span lang="de">Mittlere Geschwindigkeit löschen</span><span lang="en">Reset average speed</span></a>	  
	       <a id="switchautorange" class="switcher menuitem" href="#"><span class="fa icon-gauge-2"></span><span lang="de">Wertebereich zurücksetzen</span><span lang="en">Reset speedometer range</span></a>	  
		  <!--
		  	<a id="maxsettings" class="switcher menuitem" href="#"><span class="fa icon-upload"></span>Höchstgeschwindigkeit</a>
		  <a id="averagesettings" class="switcher menuitem" href="#"><span class="fa icon-right"></span>Mittlere Geschwindigkeit</a>
		  -->
		  <!--<a id="alarmsettings" class="switcher menuitem" href="#"><span class="fa icon-bell-alt"></span>Geschwindigkeitsalarm</a>-->
		  <!--
		  	TODO: implement later, when auto-background-management is not enough
		  	<a id="backgroundsettings" class="switcher swithhed-on" href="#"><span class="fa icon-chart-area"></span>Hintergrundmessung</a>
		  -->
    </div>

    <div id="unitsettings" class="dialog sub-dialog skin">
        <h3><span lang="en">Measure of Speedometer</span><span lang="de">Tachometer Einheit</span></h3>

	      <a id="setkmh" class="switcher switched-on unitradio" href="#"><span class="fa icon-dot-circled"></span>km/h</a>
	      <a id="setmph" class="switcher unitradio" href="#"><span class="fa icon-dot-circled"></span>mph</a>
	      <a id="setkn" class="switcher unitradio" href="#"><span class="fa icon-dot-circled"></span>kn</a>
	      <a id="setms" class="switcher unitradio" href="#"><span class="fa icon-dot-circled"></span>m/s</a>
    </div>

    <div id="altitudeunitsettings" class="dialog sub-dialog skin">
        <h3><span lang="en">Measure of Altimeter</span><span lang="de">Höhen-Einheit</span></h3>

	      <a id="setalt-m" class="switcher switched-on altunits" href="#"><span class="fa icon-dot-circled"></span>m (Meter<span lang="en">s</span>)</a>
	      <a id="setalt-ft" class="switcher altunits" href="#"><span class="fa icon-dot-circled"></span>ft (<span lang="en">Feet</span><span lang="de">Fuß</span>)</a>
    </div>

	
    <div id="moresettingsdialog" class="dialog sub-dialog skin">
        <h3><span lang="en">Settings</span><span lang="de">Einstellungen</span></h3>

	    <a id="tachosettings" class="switcher menuitem" href="#"><span class="fa icon-gauge"></span><span lang="de">Tachometer</span><span lang="en">Speedometer</span></a>
	    <a id="altitudesettings" class="switcher menuitem" href="#"><span class="fa icon-zoom-out icon-android-landscape-512px"></span><span lang="de">Einheit der Höhenanzeige</span><span lang="en">Altimeter units</span> (<span class="altitudeunit"></span>)</a>
	    <a id="settimeformat" class="switcher switched-on" href="#"><span class="fa icon-clock"></span><span lang="de">Uhr mit Sekunden</span><span lang="en">Clock with seconds</span></a>
        <a id="switchfastoptions" class="switcher switched-on" href="#"><span class="fa icon-lock-open"></span><span lang="de">Schnellauswahl</span><span lang="en">One touch settings</span></a>
        <a id="switchwarning" class="switcher switched-on" href="#"><span class="fa icon-info-circled"></span><span lang="de">Hinweise anzeigen</span><span lang="en">Show hints</span></a>
	    <a id="switchredwarning" class="switcher switched-on" href="#"><span class="fa icon-attention"></span><span lang="de">Warnungen anzeigen</span><span lang="en">Show warnings</span></a>
	    <a id="setlanguage" class="switcher menuitem" href="#"><span class="fa icon-globe"></span><span lang="de">Sprache: DEUTSCH</span><span lang="en">Language: ENGLISH</span></a>
    </div>        
    
    <!--<div id="menubutton"><span class="fa fa-ellipsis-v autofade"></span></div>-->
    
  <div id="gpswarning" class="gps-warning"><small><span lang="de">kein</span><span lang="en">no</span> </small>GPS</div>
  
	<div id="askresetmaxspeed" class="dialog yesnodialog  sub-dialog  skin">
		<h3><span lang="en">Reset max speed?</span> <span lang="de">Höchstgeschwindigkeit zurücksetzen?</span> </h3>
		<a class="btn btn-yes" href="#confirmresetmaxspeed"><span lang="en">Reset</span><span lang="de">Zurücksetzen</span></a>
		<a class="btn btn-cancel" href="#cancel"><span lang="en">Cancel</span><span lang="de">Abbrechen</span></a>
	</div>

	<div id="askresetaveragespeed" class="dialog yesnodialog  sub-dialog skin">
		<h3><span lang="en">Reset average speed?</span> <span lang="de">Mittlere Geschwindigkeit zurücksetzen?</span> </h3>
		<a class="btn btn-yes" href="#confirmresetaveragespeed"><span lang="en">Reset</span><span lang="de">Zurücksetzen</span></a>
		<a class="btn btn-cancel" href="#cancel"><span lang="en">Cancel</span><span lang="de">Abbrechen</span></a>
	</div>

</div> <!--dialogs-wrapper-->

</div> <!-- touch-wrapper -->

    <div id="splashscreen" class="screencard">
    	<p>
         <img src="res/kwd-4-title.png" />
    	</p>
    </div>
    
    <div class="toastmessage">Das ist ein Popup</div>
    
    <div id="ruler" class="ruler"></div>
    
	<script type="text/javascript">
	/* start javascript */


function kwd_showByClass(setclass) {
	// TODO: problem if was inline
	var els = document.getElementsByClassName(setclass);
	for(var i=els.length-1;i>=0;i--) {
		els[i].style.display = 'block';
	}
}

function kwd_hideById(setid) {
	
	// TODO: Teste, ob dies konsistent!!: 
	//document.getElementById(setid).kwdLastDisplay = 'andreas';
	document.getElementById(setid).style.display = 'none';	 

}
function kwd_showById(setid,reset_to) {
	if(!reset_to) reset_to = 'block';
	document.getElementById(setid).style.display = reset_to;
}


// still faster than ...Html -> nodeValue
function kwd_setElementText(element,str) {
		
	if (element.charAt(0)=='.') {
		element = element.substr(1);
		//app.Debug('found class: '+element);
		var els = document.getElementsByClassName(element);
		//app.Debug(els.length);
		//var content;
		for(var i=els.length-1;i>=0;i--) {
			//content = els[i].innerHTML;
			//app.Debug(content);
			els[i].childNodes[0].nodeValue = str;
		}
	}
	else {
		// TODO: check if there are more possibilities than # at start!!
		element = element.substr(1);
		//app.Debug(element);
		var el = document.getElementById(element);
		if (el) el.childNodes[0].nodeValue = str;		
	}
}

// TODO: still faster when already known whether class or id
function kwd_setElementHtml(element,str) {
		
	if (element.charAt(0)=='.') {
		element = element.substr(1);
		//app.Debug('found class: '+element);
		var els = document.getElementsByClassName(element);
		//app.Debug(els.length);
		//var content;
		for(var i=els.length-1;i>=0;i--) {
			//content = els[i].innerHTML;
			//app.Debug(content);
			els[i].innerHTML = str;
		}
	}
	else {
		// TODO: check if there are more possibilities than # at start!!
		element = element.substr(1);
		//app.Debug(element);
		var el = document.getElementById(element);
		if (el) el.innerHTML = str;		
	}
}


// class for global vars
function KwdTachoApp() {
	// public members
	this.language = 'en';
	this.tachounit = 'kmh';
	this.fastoptions = true;
	this.clockseconds = true;
	this.browsermode = false; // true: run in browser with 'emulator'(droidscript.js)
	this.nojquery = false;
	this.version = 1.50; 
	this.defaultMargin = 10;
	
	this.storage = {
		language : 'tacholanguage',
	};
	
	this.setFastOptions = function(fast_on) {
	
		if (typeof fast_on == 'undefined') return; // also returns undefined!
	
		var elfas = (document.getElementById('switchfastoptions')).getElementsByClassName('fa');
		if (elfas.length !=1) throw '>1 .fa inside #switchfastoptions';
	
		if(fast_on) {
			elfas[0].classList.add('icon-lock-open');
			elfas[0].classList.remove('icon-lock');
			showHint('Touch meters to change','Auf Anzeigen tippen für Umschaltungen');
			this.fastoptions = true;
			return true;
		}
		else {
			elfas[0].classList.remove('icon-lock-open');			
			elfas[0].classList.add('icon-lock');
			showHint('Go to settings to change anything','Änderugnen nur in den Einstellungen');
			this.fastoptions = false;
			return false;
		}
	};
	
	/* zentriert dialog
	 * - geht nur, wenn sichtbar!!
	 */
	this.centerVisibleDialog = function(id) {
		
		if(!id) {
			throw 'kwd: no id in centerVisibleDialogs';
			var els = document.getElementsByClassName('dialog');
		}
		else {
			var el = document.getElementById(id);
			if(el) {
				el.style.left = ((getDisplayWidth() - el.offsetWidth) / 2) + 'px';								
			}
		}
	};

}



kta = new KwdTachoApp();

// Konstanten
const storage_settings = 'kwd_tacho_settings';
const storage_tachorange = 'tachorange'; 
const storage_tachocurrentmax = 'tachocurrentmax'; // meint Höchstgeschwindigkeit
const storage_tachoaverage = 'tachoaveragegroups'; 
var tacho_defaultrange = 200;
var layout_gauges = 0; // counts number of displayed components (for layout and messages)
var clock_visible = false; // to check if Geoloaction can be paused
var clock_interval = null; // will be cleared if clock hidden (for performance)
var gpswarning_blinkinterval = null; 
var gpswarning_timeout = null;
var gpswarning_active = false; // saves state of warning (performance)
var cssgauge_visible = true; // will be set/unset by setTachoLayout  (performance)

// recognize browser
 
 

/* set language by adding/removing classes
 * lang: auto|en|de
 * 
 */
function setLanguage(lang) {

	//app.Debug('lang loaded: '+lang);
	if(!lang || lang=='auto') {
		lang = (app.GetLanguageCode()).toLowerCase(); // ! overwrite parameter value
	    if (lang=='de' || lang=='at' || lang=='li') lang = 'de'; // ! default language: en
	    else lang = 'en';
	}
	
	var elbody = (document.getElementsByTagName('body')[0]); // body is inside an array!
	if(elbody) {
		// TODO: use classList.toggle
		//$('body').removeClass('en'); // works because multiple addClass do not add more classes :-)
		elbody.classList.remove('en');	 	// check if throws error when already gone !
		//$('body').removeClass('de'); // works because multiple addClass do not add more classes :-)
		elbody.classList.remove('de');
		//$('body').addClass(lang);
		elbody.classList.add(lang); // can also be a cas of WAIT needed!
	}
	
    // make some dialogs height depending on main menu
	// outerheight -> corresponds to box-sizing!
	// must be done here because on initApp are both languages displayed + height could change with language

	//$('.sub-dialog').css('min-height',$('#settingsdialog').outerHeight()+'px');
	// TODO: cannot work when all dialogs are hidden!
	// - entweder in menustackpush als var speichern
	// - oder hier alle dialoge sichtbar machen, dann setzen, dann wieder verstecken außer den aktuellen
	// - eventuell nicht so wichtig, wenn Hintergrund abgedunkelt/aufgehellt bei Menüs (wie Diaschau auf website)
	var setheight = document.getElementById('settingsdialog').offsetHeight + 'px';
	var els = document.getElementsByClassName('sub-dialog');
	for(var i=els.length-1;i>=0;i--) {
		els[i].style.minHeight = setheight + 'px';
	}

	kta.language = lang;
}


/* gibt eine message aus
    - kapselt app.ShowPopup, um Layout und Zusatzfunktionen steuern zu können
    (z.B. stapeln von Nachrichten ähnlich log)
*/
function toastMessage(msg) {
    app.ShowPopup(msg,'bottom');
}
/* shows message depending on language
 * - first msg: in default language
 * - second msg (optionl): in second language (now just german)
 * - TODO: make sure not called before app object 'kta' is set
 * - TODO: for more than 2 languages use array or html-texts with ids which are read by jQuery
 */
function showHint (msg,msg_de) {
	if(displayHints) {
		if (msg_de && kta.language=='de') toastMessage(msg_de);
		else toastMessage(msg);
	}
}

/* starts gps sensor 
 * - checks if clock is the only display, then don't start + even stop when already running
 * TODO: useful to wait until warning at app start is gone??
 */
var gps_running = false; // prevent loc.Start() if running OR loc.Stop() if already stopped
function startGps() {
	if (typeof loc != 'undefined') {
		var clockonly = (layout_gauges==1 && clock_visible) ? true : false; // TODO could use value from displays list
		
		if (!clockonly && !gps_running) {
			loc.Start();
			gps_running = true;
		} 
		else if (clockonly) {
			stopGps();
		} 
	}
}
/* stops gps sensor
 * - prevents multiple send stop command
 */
function stopGps() {
	if (gps_running && (typeof loc != 'undefined')) loc.Stop();
	gps_running = false;
}

var gps_blinking = false;
function gpsBlink() {
	var color = (gps_blinking) ? '#dd0000' : 'black';
	//$('.gps-warning').css('color',color);
	var els = document.getElementsByClassName('gps-warning');
	for(var i=els.length-1;i>=0;i--) {
		els[i].style.color = color;
	}

	gps_blinking = !gps_blinking;
}
/* sets colors and warning text
 * - called by timeout or directly
 */
function setGpsWarning() {
	if(!gpswarning_active) {
	    //$("#gpswarning,.gps-warning").show();
	    document.getElementById('gpswarning').style.display = 'block'; // TODO: check if is not inline!
	    var els = document.getElementsByClassName('gps-warning');
	    for(var i=0; i < els.length; i++) {
	    	els[i].style.display = 'block'; // TODO: check if is not inline!
	    }
	    //$('.gps-no-warning').hide();
	    var els = document.getElementsByClassName('gps-no-warning');
	    for(var i=0; i < els.length; i++) {
	    	els[i].style.display = 'none'; 
	    }
	   
		//$('.gps').addClass('no-gps');
	    var els = document.getElementsByClassName('gps');
	    for(var i=0; i < els.length; i++) {
	    	els[i].classList.add('no-gps'); 	    
	    }
		
		gpswarning_blinkinterval = setInterval(gpsBlink,500);
		gpswarning_active = true;
	}	
}
/* removes colors and warning text
 * - usually called only directly
 * - resets the timeout 
 */
function clearGpsWarning() {
	if(gpswarning_active) {
		//$("#gpswarning,.gps-warning").hide();
	    document.getElementById('gpswarning').style.display = 'none'; // TODO: check if is not inline!
	    var els = document.getElementsByClassName('gps-warning');
	    for(var i=0; i < els.length; i++) {
	    	els[i].style.display = 'none'; 
	    }
		
	    //$('.gps-no-warning').show();
	    var els = document.getElementsByClassName('gps-no-warning');
	    for(var i=0; i < els.length; i++) {
	    	els[i].style.display = 'block'; // TODO: check if is not inline! 
	    }
	    
		//$('.gps').removeClass('no-gps'); // check if without . (dot)	
	    var els = document.getElementsByClassName('gps');
	    for(var i=0; i < els.length; i++) {
	    	els[i].classList.remove('no-gps'); 	    
	    }		
		
		if(gpswarning_blinkinterval!==null) clearTimeout(gpswarning_blinkinterval);
		gpswarning_active = false;
	}
	if(gpswarning_timeout!==null) clearTimeout(gpswarning_timeout);
	gpswarning_timeout = setTimeout(setGpsWarning,6000); // 6s is a matter of fealing :-)
}

//var previous_time = 0; // save time for check (for performance)
var previous_minutes = -1;

/* refresh display of clock
 * - called only as interval callback
 * - disabled when clock hidden (so you don't have to check this here)
 * TODO: check whether minutes/hours have changed before calling jQuery  
 */
function changeTime() {
	
    var date = new Date();
    
    if(kta.clockseconds) {
    	var s = date.getSeconds();
	    s = ":"+((s < 10) ? "0" + s : s);
	    //$('#seconds-text').text(s);
	    document.getElementById('seconds-text').childNodes[0].nodeValue = s;	
	}
    // minutes and hours are only formatted + displayed when changed:
    var m = date.getMinutes();
    if(m!=previous_minutes) {
	    previous_minutes = m;	    
	    m = ":"+((m < 10) ? "0" + m : m);
   	    var h = date.getHours();
	    h = ((h < 10) ? "0" + h : h);
	    //$('#time-text').text(h+m);
	    document.getElementById('time-text').childNodes[0].nodeValue = h+m;	
    }
    
    // this prevents warning when clock is used alone
    if (layout_gauges==1) clearGpsWarning();
} 
function startClock() {
	previous_minutes = -1; // to ensure update on restart
	clock_interval = setInterval(changeTime,1000);
	clock_visible = true;
}
function stopClock() {
	if (clock_interval !== null) clearInterval(clock_interval);
	clock_visible = false;
}

function OnConfig() {
    //ATTENTION!: don't check screen rotation result here, 
    // since width and height are still old values in WebView!
    // see $(window.resize(...)
}

//Called when application is paused.
function OnPause() 
{ 
    if (typeof settings !== 'undefined') settings.save();    
    app.PreventScreenLock(false);
	app.SetScreenMode('Normal');
    // --> TODO: ein flag setzen, so dass gpstool.change darauf reagieren und z.B. nur die wichtigsten Sachen machen
    // kann, z.B. nur die Werte weiter verarbeiten, die die für die Statistik erforderlich sind.
    if (typeof gpstool !== 'undefined') gpstool.saveAverage();
    
    stopGps(); // solange keine Hinterhrundwerte für max/mittel  
}
 
// TODO: check what it does when inside menu?
// --> the double check should prevent fade
function OnResume() 
{ 
	app.Debug("on resume");
    app.PreventScreenLock(true);
    
    startGps(); // check if error when start twice!!!
    if (typeof gpstool !== 'undefined') 
    	if (gpstool.isHud())
    		app.SetScreenMode('Game'); // TODO: evtl. in mächster DroidScript Version geändert
    resetHud();
}

// back button hides open dialogs or screen modes like hud
function OnBack()
{
    if (kta.browsermode) app.Debug('OnBack'); // why cannot see this msg??
    
	// just check if there is any open menu
	// otherwise show main menu
	if(!menustack.current()) menustack.push('settingsdialog');
	else {
		menustack.pop(); // you can read the popped element and react!
	    // no gauges warning now with *counter* 
	}
	if(menustack.current()!==false) resetMenuFade();
	resetHud(); 
	// TODO: irgendwie scheint das resetHud erst bei Klick *im* Hauptmenü zu reagieren
}

// my own app.Exit wrapper, app.Exit() must not exist more than once!
// (so i control things much better!!)
function Quit() {
    OnPause();  // nach neuesten Tests nicht automatisch
    app.Exit();
}

/* hardware menu button
*/
function OnMenu( name )
{                
    if(menustack.current()!='settingsdialog') menustack.clear();
    OnBack(); // if not cleared -> this closes main menu
}



//Called when we get a change in location.  // TODO: direkt set???
function loc_OnChange( data ) 
{ 
    gpstool.change(data);
} 

/* TODO: better receive gauge as var instead of using the global var
*/
// class
function KwdGpsTools () {
    //private:
    var speed =0.0;
    var speedfactor = 3.6;
    var lastspeed = 0.0;
    var dspeed = 0.0;
    var step = 0.0;
    var stepcount = 0;
    var lat = 0;
    var lon = 0;
    var locformat = true; // if true format in ° ' ", otherwise float val
    var alt = 0;
    var altfactor = 1;
    var hud = false;
    var that=this;
    var maxspeed = 0; 
    var tachorange = 10;
    var dochangetachorange = false;
    var speedtest = 0;
    // TODO: a class from this would be nicer
    // TODO: make SIMPLE calculation by saving just the SUM and the COUNT
    // TOOD: by this make sure there will be no +e form 
    var average_count = 0; // current count of all older groups
    var average_sum = 0;   // current sum of all older groups
    var average_grouplist = new Array();
    
    var average_itemcount = 0;
    var average_list = new Array();
    var average_groupsize = 2;
    var average_treshhold = 5400;
 
 	this.speedFactor = function(newfactor) {
 		if (newfactor) {
 			speedfactor = newfactor;
 		}	
 		return speedfactor;
 	};
 	
 	this.altitudeFactor = function(newfactor) {
 		if (newfactor) {
 			altfactor = newfactor;
 		}	
 		return altfactor;
 	};
 	
    function ConvertDDToDMS(D, lng){
        return {
            dir : D<0?lng?'W':'S':lng?'E':'N',
            deg : 0|(D<0?D=-D:D),
            min : 0|D%1*60,
            sec :(0|D*60%1*6000)/100
        };
    }

    function refreshLocDisplay() {
    	
    	var positext = document.getElementById('positiontext');
    	
        if(locformat) {                    
            var lf = ConvertDDToDMS(lat,false);
            //        lattest = parseInt(lf['deg']) + parseInt(lf['min']) /60 + parseInt(lf['sec']) / 3600;
            var tempstr = lf['deg']+'°'+lf['min']+"'"+(Math.round(lf['sec']*10)/10).toFixed(1)+'"'+lf['dir']+'<br />';
            var lf = ConvertDDToDMS(lon,true);
            tempstr += lf['deg']+'°'+lf['min']+"'"+(Math.round(lf['sec']*10)/10).toFixed(1)+'"'+lf['dir'];
            //$('#positiontext').html(tempstr);
            positext.innerHTML = tempstr;
        }
        else positext.innerHTML = lat+',<br />'+lon; 
        //$('#positiontext').html(lat+',<br />'+lon);
    }


	/* makes the correct speed value *only for output*
	*/
	function displaySpeedWithFactor(dspeed,dest_element) {
		
		dspeed *= speedfactor;
		
//		if(kta.nojquery!==undefined)
	//		app.Debug('nojquery: '+kta.nojquery);
			
        if(dspeed < 20 && speedfactor < 3.6) {	        	
        	var sss = ""+dspeed.toFixed(1);
        	sss = (sss.replace('.','<span class="valuefract">.'))+'</span>';
       		kwd_setElementHtml(dest_element,sss); // ! setElementHtml is already existent !	        	
		}
		else {
       		kwd_setElementHtml(dest_element,Math.round(dspeed)); // fast enough and must kill span if still there 	        	
		}
		
		return dspeed;
	}

    //public
    
    /* changes format of position data (longitude, latidue)
     * return: 'deg'|'decimal'
     */
    this.switchLocFormat = function() {
        locformat = !locformat;
        refreshLocDisplay();
        if (locformat) return 'deg';
        else return 'decimal';
    };
    
    /*
        collects values for average speed
          s: speed value to add
          resettime: value != 0 defines max time span (value in hours!), in this case reset the average collection! 
        
        - makes timestamp from hours
        - stores timestamp internally (must be saved!)
        - does NOT auto save averagespeed persisently (must be done seperately, eg. on resetAutoFade/resetHud, or OnPause)
		- TODO: save also pure m/s-speed for compare maxvalue + average value -> unit change must not change results
		          
         TODO: neue Implementation: 
         - einfach 2 Werte speichern: summe und Anzahl. fertig!.
         - man bräuchte aber 2 Summen, nämlich die gesamte und die bis vor Ablauf der Gleitwerte
         --> da einzige Problem ist nun der *gleitende* Mittelwert
         - deshalb auch Gruppen speichern, genau 1 je Programmstart.
         - da Zeitüberchreitung des Zeitfensters (z.B. 24h) sowieso nicht bei laufender Messnung beachtet werden soll,
    */
    this.averageSpeed = function(s,resettime) {
 
 		var i,cas,clength; // used several times
 		
		
		if (resettime && resettime > 0) { // TODO: check if works when manual reset needed
		
			// time value not yet used
			
			delete average_list;	
		}
		else {
			// TODO: völlig neue Berechnung!
			
			// first collect values
			average_grouplist.push(Math.round(s*100)/100);		
			// check if group is full
			var gs = average_grouplist.length; // only if gs is used again
			if (gs >= average_groupsize)  {
				// now add group to main list by making average value and clear grouplist
				 cas=0;
				 for(i=0;i<average_groupsize;i++) {
				 	cas += average_grouplist[i];
				 }
				cas = cas / average_groupsize;
				//app.Debug(average_grouplist);
				//app.Debug(cas);
				average_list.push(cas);
				// the main list will get cutted if too large
				clength = average_list.length;
				if (clength>average_treshhold) {
					averagelist.shift(); // or first change group size!
					clength--;
					//TODO: make startindex instead of shift, the array will cutted by storing/restoring + restarting app
				}
	
				 // noe get average from main list
				 //if (clength % 100 ==0) app.Debug ('avg main list size:'+averagelist.length);
				 //if (clength) app.Debug ('avg main list size:'+average_list.length);
				 //if (clength) app.Debug (average_list);
				 app.Debug(clength);
				 cas=0;
				 for(i=0;i<clength;i++) {
				 	cas += average_list[i];
				 }
				 cas = cas / clength;
				 //$('#averagespeedtext').text(Math.round(cas));
				 // TODO: check varbeitung der Einheiten
				 document.getElementById('averagespeedtext').childList[0].nodeValue(Math.round(cas)); // hieß es childList oder anders??
	        
				average_grouplist.length = 0 ; // slowest	        
			}
		} // else // resettime

    };
 
 	/* save function  for average speed
 	 * 
 	 * - seperate from generating for performance reasons (should be used only on pause / quit )
 	 * - makes string of array
 	 * - if array empty save empty string!
 	 * 
 	 * return: true: success; false:error
 	 */
 	this.saveAverage = function () {
	 		
	 	var str = '';
	 	var clength = average_list.length;
	 	if (clength) {
	 		try {
	 			str = JSON.stringify(average_grouplist);
	 		}
	 		catch(e) {
	 			app.Debug(e);
	 			return false;
	 		}
	 		app.Debug(str);
	 		app.SaveText(storage_tachoaverage,str);
	 	}
	 	return true;
 	};
 	/* load function for average speed
 	 * - makes array of object out of string with JSON.parse
 	 * - error while loading or empty string leaves array unchanged
 	 * return: true=success, false=nothing (sensible) loaded
 	 */
 	this.loadAverage = function() {
 		var str = app.LoadText(storage_tachoaverage,'');
 		var err=0;
 		if (str) {
 			// for the unusual case of loading after init of app delete list:
 			if(average_grouplist.length) average_grouplist.length = 0;
 			try {
 				average_grouplist = JSON.parse(str);
 			}
 			catch(e) {
 				app.Debug(e);
 				err=1;
 				average_grouplist = new Array();
 			}
 		}
 		if (err) return false;
 		else return true;
 	};
    /*
        sets the maxspeed
        - newmaxspeed: only accepted if > current maxspeed
        - newmaxspeed: < 0: reset maxspeed with value (like in this.tachoRange)
        - auto saves maxspeed persisently
        ! uses always raw m/s until display!
    */
    this.maxSpeed = function(newmaxspeed) {
        
        if(newmaxspeed && (newmaxspeed > maxspeed || newmaxspeed < 0)) {
            maxspeed = (newmaxspeed<0) ? -newmaxspeed  : newmaxspeed;
            app.SaveNumber(storage_tachocurrentmax,maxspeed); // is called quite often shortly after reset but not more often than once a second
            
			displaySpeedWithFactor(maxspeed,'#maxspeedtext');
        }
        return maxspeed;
        
    };
    
    /* call back for change by GPS
      * - uses displayspeed for tachoRange... and speed (raw) for max and average
     */
    this.change = function(newlocdata) {
		//app.Debug('loc change');        

        // if provider == network, speed has no reasonible value
        // so keep old value unless gps
        // TODO: alle Änderungen auch ohne GPS wenn möglich - z.B.  für initiale Werte
        // oder != 0 abfragen : entweder Wert !=0 oder nur von gps
        
        if (newlocdata.provider.toLowerCase() == "gps") {
			clearGpsWarning();
			
            lastspeed=speed;
            // rounding saves a lot of space when converting values to string
            speed =  newlocdata.speed;
            if (speed < 0) speed = 0; // for the case of calculation or rounding errors
            //(if speed is momentarily <0 this can disturb statictic/display functions of app)
            
            //currently not used $('#bearingtext').text(newlocdata.bearing+'°');
            //currently not used $('#bearinginfo').text('GPS');


	        //if (speedtest<50) speedtest+=0.9;
	        //else speedtest+=9;
	        //speed=speedtest;
	        
	        
	        //TODO: turn on: this.averageSpeed(speed);
	        this.maxSpeed(speed);
	        
	        var displayspeed = displaySpeedWithFactor(speed,'.speed'); // already sets the output, but returns calculated as number
	        
	        	
	        if (cssgauge_visible) { // flag for performance
		        // correct scale if >1000 or <1000
		        //if (displayspeed >= 1000 && lastspeed<1000) dona_text_scale(dona_scale4);
		        //else if (displayspeed < 1000 && lastspeed>=1000) dona_text_scale(dona_scale3);
		        
	        	if (displayspeed > 0) this.tachoRange(displayspeed); // must not be <= 0  (accidently)
	        	gauge.setValue(displayspeed); // hier den exakten float value nutzen
	        }
        }
        else {
            //$('#bearinginfo').text('Sensor');
            // gpswarning is controlled by block above only
        }
        
		// get always these values !:
		// but only set if not 0
        if (newlocdata.latitude!=0) lat = newlocdata.latitude; // TODO: check if you should round!
        if (newlocdata.longitude!=0) lon = newlocdata.longitude;    // TODO: check if you should round!
        if (newlocdata.altitude!=0) alt = newlocdata.altitude * altfactor; // TODO: save alt * factor seperatly if storage of data needed
        //currently not used  $('#accuracytext').text(newlocdata.accuracy); 
        // analog speed testing: 
        
        // for screenshots:
        //lat = 52.5162731;
        //lon = 13.3777052;
        
        //step = (speed - lastspeed) / 4;
        //stepcount=0;
        //dspeed = lastspeed;
        // window.setTimeout(this.setStep,250);

        //test
//        lat = 40.1641164;
//        lon = -7.8928645;

        //update geolocation
        refreshLocDisplay();
        
        //update altitude
        
       
		//        $('#altitudetext').text(Math.round(alt));
   		kwd_setElementText('#altitudetext',Math.round(alt)); // fast enough and must kill span if still there 	        	
    };
    
    this.isHud = function() {
    	return hud;
    };
    
    /* switch the hud (mirroring) on and off
    - sets one specific state if parameter setto is set ('on'|'off')
    */
    this.switchHud = function(setto) {
    
        if (setto=='on') hud = true;
        else if (setto=='off') hud = false;
        else hud = !hud; 
        
        var scale = hud ? -1 : 1;

        /*$("#display-container").css({
            'transform' : 'scaleX('+scale+')',
            '-webkit-transform' : 'scalex('+scale+')',
            '-moz-transform' : 'scaleX('+scale+')'
        });*/
       var dc = document.getElementById('display-container');
       dc.style.webkitTransfrom = 'scaleX('+scale+')';
       dc.style.transform = 'scaleX('+scale+')';
       
		if (hud) {
		  //$('.skin').addClass('skin-minimal');
			var elems = document.getElementsByClassName('skin');
			for(var i=0;i<elems.length;i++) {
				elems[i].classList.add('skin-minimal');
			}
		  app.SetScreenMode('Game'); // TODO: evtl. in mächster DroidScript Version geändert

		}
		else {
		  //$('.skin').removeClass('skin-minimal');
			var elems = document.getElementsByClassName('skin');
			for(var i=0;i<elems.length;i++) {
				elems[i].classList.remove('skin-minimal');
			}
		  app.SetScreenMode('Normal');
		}
    };
	
	/*
	  setzt Tacho Wertebereich in Anzeige analog hoch 
	  - newvalue enthält eine aktuelle Geschwindigkeit, die ausgewertet werden muss!
	  - wenn newvalue < 0, Max. Wert auf abs(newvalue) direkt gesetzt anstatt zu erhöhen
	  - wenn newvalue zufällig 0 -> nichts tun
	  - Automatische Wertebereich-Erhöhung kann real nicht abgeschaltet werden, sondern wird
	    im Menü lediglich auf niedrig oder hoch zurückgesetzt :-)
	  - TODO: value gleich setzen, wenn Bereich geändert, am besten auch, wenn nicht geändert
	*/
	this.tachoRange = function(newvalue) { 

    	if(newvalue) {

    	    var dochange = false;
    	    var el = document.getElementById('cssgauge');
    	    app.Debug('cssgauge display: '+el.hidden);
    	    if ((newvalue > tachorange) && (el.hidden == false)) // nichts tun wenn ananlog nicht sichtbar!
            { 
                
                // do NOT increase but directly calculate new; the divisor == step to round up
                // (this avoids jumping 5 times when starting while having e.g. 100km/h)
                // TODO: 40th step does not work properly
                if (newvalue >= 500) tachorange = Math.ceil(newvalue / 500)*500;
                else if (newvalue >= 100) tachorange = Math.ceil(newvalue / 100)*100;
                else if (newvalue >= 20) tachorange = Math.ceil(newvalue / 50)*50;
                else if (newvalue >= 10) tachorange = Math.ceil(newvalue / 20)*20;
                else tachorange  = 20;
                
                app.Debug("extended range:"+tachorange);
    	        dochange = true;
            }
            else if (newvalue < 0) {
                // this makes it possible to reset to a range
                tachorange = -newvalue;
                dochange = true;
            }
            
            // nun ist tachorange korrekt berechnet, falls nicht größer, nichts tun
            if (dochange) {
                
        	    var minors = 2;
				var maj = tachorange / 10; 
				var split = 6;
				
				if (tachorange<=10) {
				    minors = 2;
				}
				else if (tachorange<=20) {
				    minors = 2;
				}
				else if (tachorange<=50) {
				    minors = 5;
				}
				else if (tachorange<=200) {
				    minors = 2;
				}
				else if (tachorange<=300) {
				    minors = 3;
				}
				else if (tachorange<=400) {
				    maj = 50;
				    minors = 5;
				}
				else if (tachorange<=500) {
				    
				    minors = tachorange / 100;
				}				
				else {
				    minors = 2;
				}
				    
				
				var steps = tachorange / maj;
				// TODO: autoadjust by checking amount of steps
			    split = Math.floor(steps / 3 * 2);
				
        	    if(gauge) gauge.config({
					'wrapper':'cssgauge-wrapper',
					'gauge':'cssgauge',
					'size':'auto', // not yet implemented !
					'maxRange':tachorange,
					'majorStep':maj, // must be < maxRange and reasonable adjusted
					'minorTicks':minors, // should be between 0 and 5
					'overallAngle':270, // degrees, better < 340
					'value':0 // must be < max Range
        	    });
        	    // some skin classes must be set again:
        	    //if(hud)	$('.skin').addClass('skin-minimal'); // TODO: problem if multiple adds possible

        	    app.SaveNumber(storage_tachorange,tachorange);
            }
    	}
    	return tachorange; 
	};
	
	
	// construct
	
    // current maxspeed
    this.maxSpeed(-app.LoadNumber(storage_tachocurrentmax,1)); // neg. value forces set, default 1, because -0 is just 0
    // current average speed
    this.loadAverage();
    

} // KwdGpsTools


/*  AutoSettings
    sucht per jquery Elemente aus dem DOM, deren Zustand in 
    localStorage gespeichert wird, um z.B. Programmeinstellungen
    wiederherstellen zu können.
    - abhängig von bestimmten Konventionen im HTML:
        - id muss gesetzt sein
        - class 'switcher' 
        - Funktionen sollten Zustandsänderung an AutoSettings weitergeben
          (Bsp. hier siehe 'setRadio()' und 'switchClass()'
        - Zustände sollten nicht außerhalb von AutoSettings in vars gespeichert 
          werden
	
	TODO: extern (interface) alles mit boolean!

          
    TODO: PROBLEM: funktioniert in App nicht oder schlecht, 
        - Verhalten von get (kann auch *undefined* liefern!) wurde repariert
        --> Timing Problem (wegen jQuery?) besteht immer noch
        - besser wäre, alle switcher bei Programmstart in Array aufzunehmen, wenn
          load scheitert, dies würde auch Array-Vergrößern bei erstem Switch 
          sparen
*/
//class
function AutoSettings(newstoragename,newsetclass) {
    //private
    var data = new Array();
    var storagename = '';
    var setclass = 'switched-on';
    var check = "";
    
    var that = this;
    
    //public
    
    
    /*  speichert in storage wenn möglich
        - gibt false zurück, wenn speichern nicht möglich
        - verändert Struktur 'data' nicht
    */
    this.save = function() {
        
        if(storagename!='' && data.length!=0) {
            var str = JSON.stringify(data);
            window.localStorage.setItem(storagename,str);
            return true;
        }    
        return false;        
        
    };
    
    /*  lädt von storage wenn möglich
        - gibt false zurück, wenn laden nicht möglich
        - verändert Struktur 'data' nicht, wenn laden nicht möglich
    */
    this.load = function() {
        
        if(storagename!='') {
            var str = window.localStorage.getItem(storagename);
            if(str!==null) {
                data = JSON.parse(str);
                return true;
            }            
        }    
        return false;        
    };

    /* findet Element oder fügt es hinzu
        - gibt index des Elementes zurück oder -1 im Fehlerfall
    */
    this.added = function(name) {
        var i;
        var l = data.length;
        for(i=0;i<l;i++) {
            if(data[i]['name'] == name) {
                return i;
            }
        }
        
        if(i>=data.length) {
            var a = new Object();
            a['name'] = name;
            a['value'] = 'false';
            data[i] = a;

            return i;
        }
        
        return -1;
    };
    
    /*  initialisiert alle Switches
        - ändert HTML der entsprechenden Elemente
        - liest aktuelles 'data', versucht intern keinen 'load' oder 'generate'
    */        
    this.initall = function() {
        
        var i;
        var l = data.length;
        for(i=0;i<l;i++) {
            var el = document.getElementById(data[i]['name']);
            if(el) {
	            if(data[i]['value'] == 'false') {
	                //jquery: $('#'+data[i]['name']).removeClass(setclass);
	                el.classList.remove(setclass);
	            }
	            else {
	                el.classList.add(setclass);
	            }
           }
        }
    };

    /*  liest einen Wert aus Settings liste
        liefert undefined wenn Wert nicht vorhanden
    */
    this.get = function(name) {
        var i;
        var l = data.length;
        for(i=0;i<l;i++) {
            if(data[i]['name'] == name) {
                if(data[i]['value']=='true') return true;
                else return false;
            }
        }
        
        return; // ! automatically returns 'undfined' TODO: lieber String 'unset'
    };
    
    /*  setzt einen Status und erzeugt Element, wenn nicht vorhanden
        - value string!! 'true' und 'false' werden behandelt
    */
    this.set = function(name,value) {
        
        if(typeof name !== 'undefined') {
            var i = this.added(name);
            if(i!=-1) {
                data[i]['value'] = value;
                return true;
            }           
        }
        return false;
    };
    
    
    /* return: true: on, false: off
 		- value: if given sets to this (must be string 'true'|'false') (TODO: test!)
 		TODO: alles mit normalem true|false (keine Strings)
	       TODO: id statt elem, da eh wieder zurück referenziert werden muss
     */
    
    this.switchit = function(id,value) {

		if(typeof id != 'string') throw('switchit NEW!!');
		
		var elem = document.getElementById(id);  
        var sw = elem.classList.contains(setclass); // TODO: check if works!
        var setto = (value == 'true') ? true : false; // value undefined also leads to false
        
        if (sw && setto) return true; // prevent multiple set of class
        
        if(sw && !setto) {
        	// remove class may sometimes be called when there is nor more class - without effect
            //$(elem).removeClass(setclass);
            elem.classList.remove(setclass);
            this.set(id,'false');
        }
        else {
            //$(elem).addClass(setclass);
            elem.classList.add(setclass);
            this.set(id,'true');
        }

        this.save();
        return !sw;
    };
    
    /* im Gegensatz zum switch muss bei radio bei allen
       betreffenden Elementen (klasse) das Element gesetzt/erzeugt werden
       
       TODO: 'swicthed-on' in var!!
    */
    this.radio = function(klasse,id) {
    	
        
        if(typeof id != 'string') throw('kwd settings radio only IDs!');
        
        // alle der klasse auf false
        /*$(klasse).removeClass('switched-on');
        $(klasse).each(function() {
            that.set($(this).attr('id'),'false');
        });*/	
		var elems = document.getElementsByClassName(klasse);
		for(var i=elems.length-1;i>=0;i--) {
			elems[i].classList.remove('switched-on');
			this.set(elems[i].id,'false');
		} 
        
        // gesetztes auf true
        //$(elem).addClass('switched-on');
        document.getElementById(id).classList.add('switched-on');
        
        //this.set($(elem).attr('id'),'true');
        this.set(id,'true');
        
        this.save();
    };

    
    //construct
    if(newstoragename) storagename = newstoragename;
    if(newsetclass) setclass = newsetclass;
    if(this.load()) this.initall();
}



/* manages Visibility of menus or cards or any HTML elements given by id (always called 'menu' here)
 * - 
 * - push() and pop() make sure the caller does not need to know order or type or id of open menu
 * - TODO: function clear/rewind
 * - TODO: choose to not hide lower on push 
 * - TODO: save state (show/hide) of each entry
 * - TODO: find error while OnBack (if any)
 */
// class
function KwdPopupStack() {
	
	// private:
	
	var stack = new Array();
	/* adds a menu to the stack
	 * - callback will be used on pop for additional actions on pop
	 * - id must be the name used by HTML element id  
	 */
	
	//public:
	
	/* code for the *current* project, 
	 * TODO: to make this class independently provide callback mechanism!
	 */
	this.doOnChange = function(show_id,hide_id) {

		if(show_id) {
			var el = document.getElementById(show_id);
			el.style.display = 'block';
			el.scrollTop = 0;
			kta.centerVisibleDialog(show_id);
			kwd_showById('dialogs-blender');
		}
		else { // this must be only when stack empty
			kwd_hideById('dialogs-blender');			
		}
		
		if(hide_id) {
			document.getElementById(hide_id).style.display = 'none';
		}

	    window.scrollTo(0,0);
	    resetMenuFade();
	};
	
	this.push = function(id,callback) {
	
		var stackentry = new Object( {
			'id': id,
			'callback' : callback
		});
		
		var lastid;
		
		// we hide the last stackentry and
		if (stack.length) {
			lastid = stack[stack.length-1].id;
		} 
		// now show the new menu
		// id is always stored without the #, user can decide to write # or not
		if (id.charAt(0)=='#') id = id.substr(1,id.length-1);
		//app.Debug(id);
		stack.push(stackentry);
		//app.Debug(stack);		
		this.doOnChange(id,lastid);
	}; 
	
	/* removes a menu from stack
	 * - return: id of popped menu
	 * - if stack empty, do nothing and give back emptys string
	 */
	this.pop = function() {
		
		if (stack.length>=1) {
			var entry = stack.pop();
			// hide the menu to be popped
			//$('#'+entry.id).hide(); // !jQuery
			document.getElementById(entry.id).style.display = 'none';
			var lastid;
			if(stack.length) {
				lastid = stack[stack.length-1].id; // now the previous is the topmost
				//$('#'+last.id).show(); // !jQuery
			}
			this.doOnChange(lastid,entry.id);
			return entry.id;
		}
		else return '';
	};
	
	/* hides current element and empties stack
	 * 
	 */
	this.clear = function() {
 		if(stack.length) {
 			//$('#'+stack[stack.length-1].id).hide();
			var el = document.getElementById(stack[stack.length-1].id);
 			if (el) el.style.display = 'none';
 			stack.length = 0; // clear all
 		}
	};
	
	/* returns the currently visible menu of stack
	 * - does nothing but returning id,
	 * - returns FALSE if no menu there, else the id string without '#'
	 * - just use this method to check for an empty stack! 
	 */
	this.current = function () {
		if (stack.length) {
		  var e = stack[stack.length-1];
		  if (e.id) {
		      //app.Debug(e.id);
		      return e.id; // TODO: check if can be written like that!
		  }
		}
		//app.Debug('stack empty');
		return false;
	};	
} // class PopupStack


/* DisplayBox
 * - outer wrapper = display-box -> border etc.; size adjusted with css (name of wrapper not important)
 * - inner = diplay-text -> size adjusted with transform scale - can be div and still fit to text???
 *  
 * TODO: maybe better to save the dimensions of textRef in seperate vars instead of relying on not have changed the css
 */// class
function DisplayBox (newid,mode) {

	var id;
	var boxRef = null; // element in DOM
	var boxRef_padding = 0; // TODO: 2 Werte: jedes Padding einzeln!
	var textRef = null; 
	var text_w = 0;
	var text_h = 0;
	var primary = false;
	var visible = true;  // for toggle - and performance
	var firstvisible = false;
	var teststring = newid;
	
	/* gibt Namen zurück
	 * 
	 */
	this.name = function() {
		return id;
	};
	
	this.testString = function(newstr) {
		if((typeof newstr != 'undefined') && newstr) teststring = newstr;
		return teststring;
	};
	
	this.show = function() {
		if(!visible) {
			//$(boxRef).show();
			boxRef.style.display = 'block';
			visible=true;
		}
	};
	
	this.hide = function() {
		if(visible) {
			//$(boxRef).hide();
			boxRef.style.display = 'none';
			visible=false;
		}
	};
	
	this.isVisible = function() {
		return visible;
	};
	
	/* sets or removes class for first *visible* display
	 * - value stored
	 * TODO: caller must ask whether he wants digitalspeed either - or not
	 */
	this.setFirst = function(isfirst) {
		if ((isfirst && firstvisible) || (!isfirst && !firstvisible)) return;
		
		
		if (isfirst) {
			//$(boxRef).addClass('first-display');
			boxRef.classList.add('first-display');
			//app.Debug('first set to '+id);
			firstvisible = true;
		}
		else {
			//$(boxRef).removeClass('first-display');
			boxRef.classList.remove('first-display');
			app.Debug('first removed from '+id);
			firstvisible = false;
		}
	};
	
	/* passt die Größe dem umgebenden div (settings.wrapper) an
	 * - unabhängig, da bei jedem resize benötigt.
	 */
	this.scale = function(x,y,dim) {
		// manage scale + corrected position!
		// TODO: CSS scale origin des .gauge oben links
		// - the width, height of wrapper are always the innermost value 
		// - checks if width or height is limiting ("bounding box")
		if (boxRef==null || textRef==null) return;
		
		// TODO: save values on construct if scroll-dims not work!
		// ! manuell padding hinzugefügt :-(())
		var ws =  x /  text_w; 
		var hs =  y / text_h;
		var scale = 1;
		
		if(dim) {
			if(dim=='width') {
				scale = ws;
			}
			else {
				scale = hs;
			}			
		}
		else scale = (ws < hs) ? ws : hs;
				
		// TODO: should also work with transform-origin 50% 50% 0 and center text by top/left values
		// TODO: you could ask a global flag and decide whether to use webkit or not
		/*jquery: $(textRef).css({
			'-webkit-transform-origin':'50% 0 0',
			'-webkit-transform':'scale('+scale+','+scale+')',
			
			'transform-origin':'50% 0 0',
			'transform':'scale('+scale+','+scale+')'
		});		*/
		textRef.style.webkitTransformOrigin = '50% 0 0'; // TODO: check if working!
		textRef.style.webkitTransform = 'scale('+scale+','+scale+')'; // TODO: check if working!
		textRef.style.transformOrigin = '50% 0 0';
		textRef.style.transform = 'scale('+scale+','+scale+')';
		
		if(dim) {
			if(scale==ws) {
				//refit height
				//jquery: var newh = ($(textRef).height()+12) * scale; // need correction is +padding +border (due to box-sizing:border-box) 
				//jquery: $(boxRef).css('height',newh+'px');
				boxRef.style.height = (textRef.scrollHeight + 12) * scale + 'px'; // why 12 ?
				
			}
			else {
				//refit width
				//$(boxRef).css('height',$(boxRef).outerHeight()*scale); // consider box-sizing
				//jquery: var neww = $(textRef).width() * scale; 
				//jquery: $(boxRef).css('width',neww+'px');
				boxRef.style.width = textRef.scrollWidth * scale + 'px';
			}
		}
	};	
	
	this.resize = function(x,y,dim) {
		/*jquery: $(boxRef).css({
			'width':x+'px',
			'height':y+'px'
		});*/
		boxRef.style.width = x + 'px';
		boxRef.style.height = y + 'px'; //TODO: why set both already??
		// try to center text into wrapper box
		// TODO: WAIT when size of above set is not yet!! OR calculate the border/padding!
		/*jquery: $(textRef).css({
			'left':($(boxRef).innerWidth() - $(textRef).width()) / 2 + 'px' 
		});*/
		
		if(x!=0) x-= boxRef_padding*2;
		//if(y!=0) y-= boxRef;
		this.scale(x,y,dim);
		
		// TODO: make work
		// - cannot work since text_w is unscaled ori size
		//var diffw = textRef.getBoundingClientRect().width;
		var leftpos = (boxRef.clientWidth - text_w) /2;
		textRef.style.marginLeft = leftpos - boxRef_padding + 'px'; //Hier manuell die padding der  Box hinzugerechnet :-(
	};
	
	// construct displayBox
	id=newid;
	boxRef = document.getElementById(newid);
	//jquery:textRef = $('.display-text',boxRef);
	var dts = boxRef.getElementsByClassName('display-text');
	if(dts && dts.length) textRef = dts[0];
	else throw 'kwd: textRef remains null (display-box)';
	//textRef = boxRef.querySelector('.display-text'); // TODO: use when above code doesn't work 
	 
	
	//jquery: $(boxRef).show(); 
	boxRef.style.display = 'block'; // in case it is disabled initially // hide depending on app settings is done later
	if(mode) primary = true;
	
	// padding speichern:
	boxRef_padding = parseFloat(getComputedStyle(boxRef,null).paddingLeft);
	//app.Debug('padding found '+newid+': '+boxRef_padding);
	
	// fix inner text box size to preset text
	// change to block important for scale (must be inline before for getting text size) 
	/*jquery:$(textRef).css({
		'width':$(textRef).width(),
		'height':$(textRef).height(),
		'display':'block',
		'position':'absolute'  
	});*/
	// ! span tags *don't* have clientWidth/Height!
	text_w = textRef.scrollWidth || textRef.offsetWidth;
	textRef.style.width = text_w + 'px';  // set fix  from 'auto' to current width
	text_h = textRef.scrollHeight || textRef.offsetHeight; 
	textRef.style.height = text_h + 'px';  // set fix  from 'auto' to current height
	textRef.style.display = 'block';           // make block (was inline!) - TODO: check if 'inline-block' is better
	textRef.position = 'absolute';
	
	//jquery: var w = $(boxRef).width(); // save this for the object
	
	// NEW: we don't resize already since positionDisplays is coming
	
} // class displayBox


/* verwaltet nur noch die Objekte vom Typ 'displayBox', die im displays-wrapper als zusätzliche Displays zusammengefasst sind.
 * - nicht nur List-Funktionen sondern auch visuelle Interaktionen und Abhängigkeiten (z.B. Schriftgrößen)
 * - TODO: id_maxwidth: id von HTMl-Element, definiert, welches durch seine Schriftgröße die Größe der anderen bestimmen soll
 * - TODO: id_maxheight: id von HTMl-Element, definiert, welches durch seine Schriftgröße die Größe der anderen bestimmen soll
 */
function DisplayBoxList(id_maxwidth) {
	var idmaxwidth;
	var list = new Array();
	
	/* adds an element to list
	 * id: id of HTML tag
	 */
	this.add = function(id,reset_text) {
	
		var box = new DisplayBox(id,(id==idmaxwidth)); // ! boolean result for 2nd param
		list.push(box);
		// TODO: use inner vars of new box for reset text since the elements are already found!
		
		//jquery: if(reset_text)	$('.display-text','#'+id).text(reset_text); 
			
		if(reset_text) {
			var el = document.getElementById(id);
			if (el) {
				
				var dts = el.getElementsByClassName('display-text');
				if(dts && dts.length) dts[0].innerHTML = reset_text;
			}
		}	
		
		return box;			
	};
	
	/* returns object with certain id
	 * - TODO: provide function to return object by index, or return all (or at least length of array)
	 */
	this.get = function(id) {
		for(var i=0;i<list.length;i++) {
			if(list[i].name()==id) return list[i];
		}	
		return null;
	};
	
	/* returns true if all displays (except digitalspeed) are hidden
	 * 
	 */
	this.noneVisible = function() {
		for(var i = list.length-1; i >= 0; i--) {
			if (list[i].isVisible()) return false;
		}
		return true;
	};
	
	/* verschiedene Einpass-Funktionen
	 * - ! z.Z. nur für stapel übereinander geeignet
	 * TODO: immer noch fehler, da in positionDisplays digitalspeed nicht mit gerechnet, aber hier mit verarbeitet
	 * TODO: nur gerade sichtbare einberechnen
	 * TODO: style für :first dynamisch für ersten sichtbaren
	 */
	this.scaleTo = function(x,y) {
			var i;
			
			if(list.length>=3) { // just to be saver from errors
				// get visibles:
				// - there are just 2 possible entries which need the border (can be !first)
				// - TODO: this as a general rule/loop
				list[0].setFirst(true); // time
				var check = (!list[0].isVisible()); // hope check is getting boolean			
				list[1].setFirst(check); 
				check = (!list[0].isVisible()) && (!list[1].isVisible());
				list[2].setFirst(check); 
			}			
			
			var c = 0;
			// ! only works when #digitalspeed is first in list !
			// ! counts from second entry 
			for(i=0;i<list.length;i++) { // always loop forward here!
				if (list[i].isVisible()) {
					c++;
				}
			}


			if(y==0) { // normal screen wide
				for (i=list.length-1;i>=0;i--) {
					list[i].resize(x,0,"width");	
				}
				app.Debug('scaled to max h');				
			}
			else {
				//app.Debug('visible displays: '+c);
				var dy = y/c; // c generated above
			
				for (i=0;i<list.length;i++) {
					//TODO: *must* calculate outerWidth(true)
					//on .display-box for using space
					list[i].resize(x,dy,"");						
				}
				app.Debug('scaled to h ='+dy);								
			}
	};
	// construct
	idmaxwidth = id_maxwidth;
	if (idmaxwidth.charAt(0)=='#') idmaxwidth = idmaxwidth.substr(1,id.length-1);	
} // class displayBoxList


/* verwaltet Objekte vom Typ 'displayBox', aber nur alles was zum digital-speed wrapper gehört
 */
function DigitalSpeedBoxList(id_maxwidth) {
	var idmaxwidth;
	var list = new Array();
	
	/* adds an element to list
	 * id: id of HTML tag
	 */
	this.add = function(id,reset_text) {
	
		var box = new DisplayBox(id,(id==idmaxwidth)); // ! boolean result for 2nd param
		list.push(box);
		// TODO: use inner vars of new box for reset text since the elements are already found!
		
		//jquery: if(reset_text)	$('.display-text','#'+id).text(reset_text); 
			
		// ! with this code only *one* child of the 'id' is processed!:
		if(reset_text) {
			var el = document.getElementById(id);
			if (el) {
				var dts = el.getElementsByClassName('display-text');
				if(dts && dts.length) dts[0].innerHTML = reset_text;
			}
		}	
		return box;			
	};
	
	/* returns object with certain id
	 * - TODO: provide function to return object by index, or return all (or at least length of array)
	 */
	this.get = function(id) {
		for(var i=0;i<list.length;i++) {
			if(list[i].name()==id) return list[i];
		}	
		return null;
	};
	
	/* returns true if all displays (except digitalspeed) are hidden
	 * 
	 */
	this.noneVisible = function() {
		for(var i=0;i<list.length;i++) {
			if (list[i].isVisible()) return false;
		}
		return true;
	};
	
	/* verschiedene Einpass-Funktionen
	 * - ! z.Z. nur für stapel übereinander geeignet
	 * TODO: immer noch fehler, da in positionDisplays digitalspeed nicht mit gerechnet, aber hier mit verarbeitet
	 * TODO: nur gerade sichtbare einberechnen
	 * TODO: style für :first dynamisch für ersten sichtbaren
	 */
	this.scaleTo = function(x,y) {
			var i;
			if(list.length>=3) { // just to be saver from errors
				// - TODO: see DisplayBoxList
				list[0].setFirst(true); // digitalspeed
				list[1].setFirst(true); // time
				var check = (!list[1].isVisible()); // hope check is getting boolean			
				list[2].setFirst(check); 
				check = (!(list[1].isVisible()|| list[2].isVisible()));
				list[3].setFirst(check); 
			}
			else {
				if(list.length) list[0].setFirst(true);
			}			
			
			dy = y;
			// TODO: calculate more, when average and max there

			if(y==0) { // normal screen wide
				for (i=list.length-1;i>=0;i--) {
					list[i].resize(x,0,"width");	
				}
				app.Debug('scaled to max h');				
			}
			else {
				//app.Debug('visible displays: '+c);
				var dy = y/c; // c generated above
			
				for (i=0;i<list.length;i++) {
					if (list[i].name()=='digitalspeed') {
					    // TODO: do nothing here
						//list[i].resize(x,0,"width");
					}
					else {
					//TODO: *must* calculate outerWidth(true)
					//on .display-box for using space
						list[i].resize(x,dy,"");						
					}	
				}
			}
	};
	
} // class DigitalSpeedBoxList


/* verwaltet Objekte vom Typ 'displayBox', aber nur alles was zum digital-speed wrapper gehört
 * TODO: teste prototype/ "Vererbung" mit Basisklasse
 */
function AnalogSpeedBoxList() {
	var list = new Array();
	
	/* adds an element to list
	 * id: id of HTML tag
	 */
	this.add = function(id,reset_text) {
	
		var box = new DisplayBox(id,false); // ! boolean result for 2nd param - NOT USED HERE
		list.push(box);
		// TODO: use inner vars of new box for reset text since the elements are already found!
		
		//jquery: if(reset_text)	$('.display-text','#'+id).text(reset_text); 
			
		// ! with this code only *one* child of the 'id' is processed!:
		if(reset_text) {
			var el = document.getElementById(id);
			if (el) {
				
				var dts = el.getElementsByClassName('display-text');
				if(dts && dts.length) dts[0].innerHTML = reset_text;
			}
		}	
		return box;			
	};
	
	/* returns object with certain id
	 * - TODO: provide function to return object by index, or return all (or at least length of array)
	 */
	this.get = function(id) {
		for(var i=0;i<list.length;i++) {
			if(list[i].name()==id) return list[i];
		}	
		return null;
	};
	
	/* returns true if all displays (except digitalspeed) are hidden
	 * 
	 */
	this.noneVisible = function() {
		for(var i=0;i<list.length;i++) {
			if (list[i].isVisible()) return false;
		}
		return true;
	};
	
	/* verschiedene Einpass-Funktionen
	 * - ! z.Z. nur für stapel übereinander geeignet
	 * TODO: immer noch fehler, da in positionDisplays digitalspeed nicht mit gerechnet, aber hier mit verarbeitet
	 * TODO: nur gerade sichtbare einberechnen
	 * TODO: style für :first dynamisch für ersten sichtbaren
	 */
	this.scaleTo = function(x,y) {
			var i;
			
			if(list.length>=3) { // just to be saver from errors
				// get visibles:
				// - there are just 2 possible entries which need the border (can be !first)
				// - TODO: this as a general rule/loop
				list[0].setFirst(true); // digitalspeed
				list[1].setFirst(true); // time
				var check = (!list[1].isVisible()); // hope check is getting boolean			
				list[2].setFirst(check); 
				check = (!(list[1].isVisible()|| list[2].isVisible()));
				list[3].setFirst(check); 
			}			
			
			var c = 0;
			// ! only works when #digitalspeed is first in list !
			// ! counts from second entry 
			for(i=1;i<list.length;i++) { // always loop forward here!
				if (list[i].isVisible()) {
					c++;
				}
			}


			if(y==0) { // normal screen wide
				for (i=list.length-1;i>=0;i--) {
					list[i].resize(x,0,"width");	
				}
				app.Debug('scaled to max h');				
			}
			else {
				//app.Debug('visible displays: '+c);
				var dy = y/c; // c generated above
			
				for (i=0;i<list.length;i++) {
					if (list[i].name()=='digitalspeed') {
					    // TODO: do nothing here
						//list[i].resize(x,0,"width");
					}
					else {
					//TODO: *must* calculate outerWidth(true)
					//on .display-box for using space
						list[i].resize(x,dy,"");						
					}	
				}
				app.Debug('scaled to h ='+dy);								
			}
	};
	
} // class AnalogSpeedBoxList


// in browser global var important:
var gauge = null;

//TODO: stop timeout by scroll event
function fadeMenus() {
	//if(menustack.current()!==false) $('.dialog').fadeOut();// TODO: fade mit complete function
	menustack.clear();
}
var menutimeout = false;
function resetMenuFade() {
	if(menutimeout!==false) clearTimeout(menutimeout);
	var newtimeout = 1000*60; // 60s
	if(menustack.current()=='infocard') newtimeout*=4; // 4 min
	menutimeout = setTimeout(fadeMenus,newtimeout);
}
var fadetimeout = false;

// only called onInit and OnBack
// function on ice since we don't need infos on the main screen now
/*function resetAutoFade() {
	
    app.SetScreenMode( "Normal"); // show statusbar    
    app.PreventScreenLock(false); // display timeout on again

    if(fadetimeout!==false) clearTimeout(fadetimeout);

    $('.autofade').show();
    $('.test').css({ 'opacity': '1.0' });

    
    // TODO: class "preventfade" oder so
    // is now handled by PopupStack :-)
    if(!menustack.current()) {
        fadetimeout = setTimeout(fadehud,5000);
		app.Debug("fade timeout set, since no menus open");
    } else app.Debug("fade DENIED");
}
*/
function fadehud() {
    
    // restart counter if something is in the way:
    // TODO: class "preventfade" oder so
    // TODO: hidden abfrage geht nicht :-(
    if(!menustack.current()) {
    	// TODO: use .autofade again for color/backgroundcolor of several elements e.g. gauge 
        //$('.autofade').fadeOut('slow');
		//$('#hg').addClass('hgchange');
		document.getElementById('hg').classList.add('hgchange');
    }
    else clearTimeout(fadetimeout);
}


/* does only the lock and fullscreen
 * - no fading or hiding (until needed again) 
 * - TODO: fullscreen geht evtl.erst durch nächste grafische Änderung (???)
 */
function resetHud() {

    kwd_showByClass('autofade');
    
    //$('#hg').removeClass('hgchange');
    document.getElementById('hg').classList.remove('hgchange');
    
    
    if(fadetimeout!==false) clearTimeout(fadetimeout);

	if (!menustack.current()) {
	    //app.SetScreenMode( "Full"); // deaktiviert wegen Einfluss auf tap-event :-(
        fadetimeout = setTimeout(fadehud,5000);
	}	
	else {
	    //app.SetScreenMode( ""); // show statusbar    
	    //app.PreventScreenLock(false); // display timeout on again
	}
	
	// TODO: make info of advertising here :-)
	if (layout_gauges < 1 && !menustack.current()) kwd_showById('no-gauges');
	//else $('#no-gauges').hide();
	else kwd_hideById('no-gauges');
}


/* setzt analog und digital-Tacho korrekt einzeln oder übereinander
    - da es nur gleiche Aufrufe gab, jetzt keine Parameter mehr- Elemente direkt genutzt
    - settings Struktur muss initialisiert sein!
    - NEW: sub-elements ar hidden when whole tacho is hidden
*/
function setTachoLayout() {
     
    if (settings.get('tachoswitch')!=false) {
    	
	  //$('#tacho-container').show();
	  var el = document.getElementById('tacho-container');
	  if (el) el.style.display = 'block';
	 
	                   	
	    var a;
	    var d;
	    if (settings.get('digitalanalog')!=false) a = d = true;
	    else {
			a = (settings.get('analog')==false) ? false:true;
			d = (settings.get('digital')==false) ? false:true;
		}
	
	    if(a && d) {
	        cssgauge_visible = true;
	        document.getElementById('cssgauge-wrapper').style.top = '10px';
	        
	        //$('#cssgauge-wrapper').show();
	        //document.getElementById('cssgauge-wrapper').style.display = 'block';  // just see if error :-)
	        //$('#digital-on-analog').show();    
	        document.getElementById('digital-on-analog').style.display = 'block';
	        //$('#cssgauge').addClass('dona');
	        document.getElementById('cssgauge').classList.add('dona');
	        displayDigitalspeed.hide();
	        //$('#digitalspeed-wrapper').hide();
	        document.getElementById('digitalspeed-wrapper').style.display = 'none';   
	    }
	    else if (a && !d) {
	        cssgauge_visible = true;
	        document.getElementById('cssgauge-wrapper').style.top = '10px';
	        //kwd_showById('cssgauge-wrapper'); // $('#cssgauge-wrapper').show(); 
	        kwd_hideById('digital-on-analog'); //$('#digital-on-analog').hide();
	        document.getElementById('cssgauge').classList.remove('dona'); //$('#cssgauge').removeClass('dona');
	        displayDigitalspeed.hide();
	        kwd_hideById('digitalspeed-wrapper'); //$('#digitalspeed-wrapper').hide();   
	    }
	    else if (!a && d) {
	        cssgauge_visible = false;
	        document.getElementById('cssgauge-wrapper').style.top = '-2000px';
	        //$('#cssgauge-wrapper').hide();
	        //document.getElementById('cssgauge-wrapper').style.display = 'none';	        
	        displayDigitalspeed.show();
	        //$('#digitalspeed-wrapper').show();
	        document.getElementById('digitalspeed-wrapper').style.display = 'block';   
	    }
	    else {
	        cssgauge_visible = false;
	        document.getElementById('cssgauge-wrapper').style.top = '-2000px';
	        //kwd_hideById('cssgauge-wrapper'); //$('#cssgauge-wrapper').hide();
	        displayDigitalspeed.hide();
	        kwd_hideById('digitalspeed-wrapper'); //$('#digitalspeed-wrapper').hide();
	    }
	}
	else {
		//$('#tacho-container').hide();
		kwd_hideById('tacho-container');
		cssgauge_visible = false;
		displayDigitalspeed.hide();
	}

}


//Add messages to log.
// log is an array since we don't when we can first access the output we like
// thus array can be read later
logarray = new Array(); // global
function Log( msg ) 
{ 
    logarray.push(msg);
    if (kta.browsermode) app.Debug(msg);
    /*
if( txt.GetLineTop( txt.GetLineCount() ) >= 0.2 )  
        log.shift(); 
    log.push( msg + "\n" ); 
    txt.SetText( log.join("") );
*/
    //txt.SetText(msg);
} 

function getDisplayHeight() {
	var h;
	
 	if(kta.useSystemSize && window.devicePixelRatio) {
		h = app.GetDisplayHeight() / window.devicePixelRatio; 		
 	}
 	else { 
	 	//TODO: problem: when sys you must get css pixel ratio
	    // get vars and test, since we got problems with body.client... vs. window.innerheight
		h = window.innerHeight || document.documentElement.clientHeight	|| document.body.clientHeight;
	}
	
	return h;
}

function getDisplayWidth() {
	
	var w;
	
 	if(kta.useSystemSize && window.devicePixelRatio) {
		w = app.GetDisplayWidth() / window.devicePixelRatio; 		
 	}
 	else { 
	 	//TODO: problem: when sys you must get css pixel ratio
	    // get vars and test, since we got problems with body.client... vs. window.innerheight
		w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		
		//app.Debug('display innerWidth: '+window.innerWidth);
		//app.Debug('display documentElement.clientWidth: '+document.documentElement.clientWidth);
		//app.Debug('display body.clientWidth: '+document.body.clientWidth);
		//app.Debug('display $(window).width: '+$(window).width());
	}
	
	return w;
}

/* berechnet alle Größen und Positionen der Anzeigen
 * - initial: gesetzt wenn bei Programmstart aufgerufen
 */
function scaleDisplays(initial) {
		
    app.Debug("scaleDisplays: "+(initial ? 'app start' : 'normal'));
    // TODO: catch the case window.devicePixelRatio is not existent or set to 0 (could be in old browser versions)
    app.Debug('window.devicePixelRatio: '+window.devicePixelRatio);
 
	
	var screen_h = getDisplayHeight();
	var screen_w = getDisplayWidth();
	var def_margin = kta.defaultMargin;

    var w = 0;
    var h = 0;
    
    
    if (screen_w <  screen_h) {
       isLandscape = false;
       w = screen_w;
    }
    else {
       isLandscape = true;
       w = h = screen_h;
    }
    
	// set the positioners to a certain initial width:
	// (otherwise displays can not init to a certain size)
	//$('.positioner').css('width',screen_w); // first set screen width for all
	var posis = document.getElementsByClassName('positioner');
	for (var i=posis.length-1;i>=0;i--) {
		posis[i].style.width = screen_w - (def_margin * 2) + 'px';	
	}

    var i = 0;
    
    //app.Debug (w2);
    
    // gauge will be centered later
//    $('#cssgauge-wrapper').css({
  //  	'width':w+'px',
    //	'height':w+'px'
    //});
    if (cssgauge_visible) {
	    var el = document.getElementById('cssgauge-wrapper');
	    if (el) {
	    	el.style.width = w-(def_margin*2) + 'px';
	    	el.style.height = w-(def_margin*2) + 'px';
	    }
	    gauge.scale();
    }


        
//    else $('#cssgauge-wrapper').css({
//    	'left':'10px',
//    	'top':'10px'
//    });
    
    // zentriere alle Dialoge:
	// - nur sichtbare
	// - wird nur gebraucht on resize mit offenem dialog
	var els = document.getElementsByClassName('dialog');
	for(i=els.length-1;i>=0;i--) {
		//app.Debug('computed:'+getComputedStyle(els[i],null).display);
		if(getComputedStyle(els[i],null).display != 'none') {
			kta.centerVisibleDialog(els[i].id);
		}
	}
	//kta.centerVisibleDialogs(); // wenn id übergeben wir nur der eine geändert
	    
    if (initial) {    
    
		// make all dialogs hidden now 

	    // digital on analog speed size
	    // now orientated to position and size of #cssgauge (not screen at all!)
	    // ! note that this is only needed when *initial* since it is scaled together with gauge 

		//var cssgaugewidth = $('#cssgauge').width(); // here NOT outerWidth! 
		var cssgaugewidth = document.getElementById('cssgauge').clientWidth; // here NOT outerWidth! 
	    var wdona = cssgaugewidth * 0.4; 
	    var newfontsize = wdona/2;
	    
		dona.resize(wdona,0,'width'); // glob var
		
	    /*jquery:$("#digital-on-analog").css({
	        'left': (cssgaugewidth - $('#digital-on-analog').width()) / 2,
	        'top':  (cssgaugewidth - $('#digital-on-analog').height()) / 2
		});*/
		// TODO: you must WAIT or try to make is as ONE (read the diff between inner width and width --> know in advance which result width will be)
		var el = document.getElementById('digital-on-analog');
		el.style.left = (cssgaugewidth - el.clientWidth) / 2 + 'px';
		el.style.top =  (cssgaugewidth - el.clientHeight) / 2 - 10 + 'px'; // 10px oberhalb Miitt

	    // size and position of info (km/h) on analog must depend on cssgauge
	    /*jquery: $('#info-on-analog').css({
	        'width':cssgaugewidth/2.7+'px',
	        'height':'auto',
	        'top':cssgaugewidth*0.73+'px',
	        'left':((cssgaugewidth-(cssgaugewidth/2.7))/2)+'px', // must be same ratio like in width
	        'font-size':cssgaugewidth/20+'px',
	        'line-height':'1em'
	    });*/
		var el = document.getElementById('info-on-analog');
		if(el) {
			el.style.width = cssgaugewidth/2.7+'px';
			el.style.height = 'auto';
			el.style.top = (cssgaugewidth*0.73)+'px';
			el.style.left = ((cssgaugewidth-(cssgaugewidth/2.7))/2)+'px', // must be same ratio like in width
			el.style.fontSize = (cssgaugewidth/20)+'px';
			el.style.lineHeight = '1em';
		}
	
	    //$('#digital-on-analog .speed').css({'font-size':''+newfontsize+'px'});
	    // position digital
	    // dona-text is a div inside:
	    
	    // dona-text 
	    // - save width with max. digits (4)
	    // - make the width fixed
	    // - now you scale to a) size with 4 digits b) to bigger size with 3 digits
	    // - for b) you must calculate the difference in width (about 1/4 == 1 digit)

        
        // TODO: this is all disabled since 26.9. 15:50 because we want introduce dona as a display-box
        /*jquery
        $('#dona-text').css({
            // the width will be set her ONCE
            'width': dona_scalebase + 'px'
        });
        
        // compute scale for 4 digits (0000):
        dona_scale4 = dona_space / dona_scalebase;
        dona_scale3 = dona_space / (dona_scalebase*0.75);
        dona_text_scale(dona_scale3);
        // replace inital 0000 text
        $('#dona-text').text('0');

	    // only correct centered position
	    // - the css width is not changed anymore
	    // - must take width of #digital-on-analog as ref
	    $('#dona-text').css({
	        'left': ($('#digital-on-analog').width() - $('#dona-text').width()) / 2 + 'px', 
	        'top': ($('#digital-on-analog').height() - $('#dona-text').height()) / 2 + 'px'
	    });
	    */
    }
}    // scaleDisplays

/* adjusts positions, proportions and sizes of displays,
 * depending on which display is currently visible
 * - also perfoms scaling of displays
 * - ! do not set height of positioner but of wrapper
 * 
 * - TODO: nimm Höhe und Breite von app.DisplayWidth/Height, da sonst software backbutton höhe nicht beachtet wird (Test)
 * - TODO: Idee: breite,höhe und layoffset in Object DisplayBox integrieren - dort positioner finden lassen (.parent() in jQuery)
 */
function positionDisplays() {
		
	
	var hscreen = getDisplayHeight(); // TODO: put into kta!
	var screen_w = getDisplayWidth();
	var def_margin = kta.defaultMargin;
	
	// TODO inside display objects??
	// only use this on outer #...-positioner
	var digitalspeed_height =  0; // only needed later as result value
	var digitalspeed_width = 0;  // must be set when visible!
	var digitalspeed_top = 0;
	
	var displays_height = hscreen;
	var displays_width = screen_w;
	var displays_top = 0;
  	
 	//app.Debug('position screen: '+screen_w+'x'+hscreen);
 	
	// TODO: may be better more complicated "if" but fewer calculations!
	// - analog: never resize (until ZOOM is introduced) but influences displays
	// - digitalspeed: always scaleto y=free, depending on displays visible, only height at last
	// - displays visible: always scaleto y=free/auto, but dependend on width given by tacho
	
	// analog (only center or not)
				
	var cssgaugewrapper = document.getElementById('cssgauge-wrapper');


	if(cssgauge_visible) {
		
		var gaugeleft = 0;
		if (isLandscape && displays.noneVisible()) {
			gaugeleft = (screen_w - cssgaugewrapper.offsetWidth)/2;
		}
		cssgaugewrapper.style.top = 0;
		cssgaugewrapper.style.left = gaugeleft + 'px';
		/*$('#cssgauge-wrapper').css({
			'top':'0px',
			'left': gaugeleft+'px'
		});*/		
	}
	
	// digital (scale full or half)
	
	else if (displayDigitalspeed.isVisible()) {

		digitalspeed_width = screen_w;
		
		if (isLandscape && !displays.noneVisible()) {
			digitalspeed_width = screen_w / 2;
		}
		
		/*jquery: $('#digitalspeed-positioner').css({ // you can set with but not height to absolute
			'width':digitalspeed_width+'px'
		});*/
		document.getElementById('digitalspeed-positioner').style.width = digitalspeed_width+'px';
		// screen cannot be sooo stretched, that resize must depend on height in landscape mode
		// you can use scaleto (although it is called twice when displays visible) -> TODO:
		//TODO: also easier in object: before each scaleto, height must reset to 'auto'
		//$('#digitalspeed-wrapper').css('height','auto');
		var el = document.getElementById('digitalspeed-wrapper');
		el.style.height = 'auto';				
		//displays.scaleTo($('#digitalspeed-wrapper').width(),0); // TODO: check if you have to WAIT
		displayDigitalspeed.resize(el.clientWidth,0,'width');
		//displays.scaleTo(el.clientWidth,0); // TODO: check if you have to WAIT
		
		// must be after scale
		//digitalspeed_height = $('#digitalspeed-wrapper').outerHeight(true);
		digitalspeed_height = parseFloat(el.offsetHeight  + el.style.marginTop + el.style.marginBottom); // you really have to WAIT here!!!!

		if(isLandscape) {
			digitalspeed_top = (hscreen - digitalspeed_height)/2;
		}
		
	}
	
	// displays-block
	
	var displayswrapper = document.getElementById('displays-wrapper');

	if(!displays.noneVisible()) {

		//$('#displays-wrapper').show();
		displayswrapper.style.display = 'block';
		
		
		// width only cut in landscape
		if(isLandscape) {
			if(displayDigitalspeed.isVisible()) {
				displays_width -= digitalspeed_width;
			}
			else if (cssgauge_visible) {
				//displays_width -= $('#cssgauge-wrapper').outerWidth(true);
				// TODO: check if 'auto' or other strings can be here 		
				// TODO: geht so nicht!
				displays_width -= parseFloat(cssgaugewrapper.offsetWidth) + def_margin;
			}
		}
		// and height in portrait
		else {
			if(displayDigitalspeed.isVisible()) {
				displays_top = digitalspeed_height + def_margin;
			}
			else if (cssgauge_visible) {
				//displays_top = $('#cssgauge-wrapper').outerHeight(true);
				displays_top = parseFloat(cssgaugewrapper.offsetHeight) + def_margin;
			}
			displays_height -= displays_top;
		}
				
		// left position and width
		// TODO: more calcs???
		/*jquery: $('#displays-positioner').css({
			'width':displays_width+'px',
			'left':screen_w-displays_width+'px'
		});*/
		var displayspositioner = document.getElementById('displays-positioner');
		displayspositioner.style.width = displays_width+'px';
		displayspositioner.style.left = screen_w-displays_width+'px';
		
		// get offset  for layout (borders margin) depending on landscape
		// TODO: you have to WAIT again
		var layoutoffset_x = displays_width - displayswrapper.clientWidth; // TODO: make it *once* and save
		var layoutoffset_y = displayspositioner.clientHeight - displayswrapper.clientHeight; // TODO: make it *once* and save
		//app.Debug('offsets:'+layoutoffset_x+'-'+layoutoffset_y);
		
		//TODO: also easier in object: before each scaleto, height must reset to 'auto'
		//$('#displays-wrapper').css('height','auto');
		displayswrapper.style.height = 'auto';
		displays.scaleTo(displays_width-layoutoffset_x,0); // y:0 for receiving maximized heights 
		
		if (displays_height < (displayswrapper.offsetHeight + def_margin*2)) { 
			displays.scaleTo(displays_width-layoutoffset_x,displays_height-layoutoffset_y); // not hspace but inner height due to layout of wrapper!!
		}
				
		// y center the scaled displays if not height > hscreen
	
		if (isLandscape) { // y center only in landscape now			
			displays_height = parseFloat(displayswrapper.offsetHeight + displayswrapper.style.marginTop + displayswrapper.style.marginBottom); // must be taken after scaleTo !
			if (displays_height < hscreen) displays_top = (hscreen - displays_height) / 2;	
		}				
		
		// change vars to adjust digitalspeed-positioning
		
	} // displays visible
	else {
		// this is always when no displays seen:
		//$('#displays-wrapper').hide();
		displayswrapper.style.display = 'none';
	}
	
	
	// adjust vertical position + height of displays and digitalspeed
	// - height can be preset by scaleTo (but not manually/directly)
	// - top must not be set already
	 
	if (isLandscape && displayDigitalspeed.isVisible() && !displays.noneVisible()) {

		// check which is larger!
		if(displays_height>digitalspeed_height) {				
			digitalspeed_height = parseFloat(displayswrapper.offsetHeight + displayswrapper.style.marginTop + displayswrapper.style.marginBottom);
			digitalspeed_top = displays_top;
			
			displays_height = 'auto';
		}
		else {
			// displays set top to digitalspeed
			displays_top = digitalspeed_top;
			//displays_height = $('#digitalspeed-wrapper').outerHeight(); // does work when both things have same layout
			var digiwrap = document.getElementById('digitalspeed-wrapper');
			displays_height = digiwrap.offsetHeight + digiwrap.style.marginTop + digiwrap.style.marginBottom; // does work when both things have same layout			
			digitalspeed_height= 'auto';
		}		
	}
	else { 
		// may be double // TODO: remove when else working
			displays_height = 'auto';
			digitalspeed_height = 'auto';		
	}
	
	// set top and height of digital + displays
	
	/*$('#digitalspeed-positioner').css({
		'top':digitalspeed_top+'px',
		'left':0                           // just to be sure
	});*/
	var digipos = document.getElementById('digitalspeed-positioner');
	digipos.style.top = digitalspeed_top+'px';
	digipos.style.left = 0;
	
	//$('#digitalspeed-wrapper').css('height',digitalspeed_height); // ! height can also be string "auto"
	document.getElementById('digitalspeed-wrapper').style.height = digitalspeed_height + 'px';
		
	/*$('#displays-positioner').css({
		'top':displays_top+'px',
		'left':screen_w - displays_width +'px'
	});*/
	var dispos = document.getElementById('displays-positioner');
	dispos.style.top = displays_top + 'px'; // TODO: check if works better without px
	dispos.style.left = (screen_w - displays_width) + 'px'; // TODO: check if works better without px
	
	//$('#displays-wrapper').css('height',displays_height); // ! height can also be string "auto"
	displayswrapper.style.height = displays_height + 'px';
	
}


/* central proc to save/restore the tacho range (persistent app settings).
  mode: "load" | "save" (if not set, performs load!)
  value: speed to be set (if "load", value is default in case load fails), if value not set or set to <=0, the CURRENT value will be taken if available
  return: -1 : error, else value which has been set
  
  ! save routine is inside gpstool.tachoRange
  
  TODO: check if it is possible that function runs before gpstool is defined!
*/
function resetTachoRange(mode,value) {
    
    // TODO: test change value
    
    if (mode=='save') {
        
        if (value && value>0) {
            gpstool.tachoRange(-value); // minus --> force set
        }
        else value=-1;
    }
    else {
        var c = app.LoadNumber(storage_tachorange,value);  // default==10, if no value found
        gpstool.tachoRange(-c); // neg. value -> force set    
    }

    return value;
}
    
 
// global vars
var displayHints = true;
/*
zählt bis 2 oder 3 (mit resize) um initApp() zu starten
10: init bereits ausgeführt */

function setTachoUnits(newunits) {
	var txt = '';
	var factor = 1;
	switch(newunits) {
		case 'mph' : txt = 'mph'; factor = 2.236936; showHint('Miles per hour','Meilen je Stunde'); break;
		case 'ms'  : txt = 'm/s'; factor = 1; showHint('Meters per second','Meter je Sekunde'); break;
		case 'kn'  : txt = 'kn'; factor =  1.9438445; showHint('Knots','Knoten'); break;
		default : txt = 'km/h'; factor =   3.6; showHint('Kilometers per hour','Kilometer je Stunde'); break;
	}
	gpstool.speedFactor(factor);
	//$('.tachounit').text(txt);
	var els = document.getElementsByClassName('tachounit');
	for(var i=els.length-1;i>=0;i--) {
		els[i].innerHTML = txt; // TODO: use nodeValue		
	}
	gpstool.maxSpeed(-gpstool.maxSpeed()); // the max-value display with current value 
}    

function setAltimeterUnits(newunits) {
	var txt = '';
	var factor = 1;
	if(newunits=='setalt-ft') {
		txt = 'ft';
		factor = 3.280839;
		showHint('Feet','Fuß');
	}
	else {
		txt = 'm';
		factor = 1;
		showHint('Meters','Meter');
	}
	gpstool.altitudeFactor(factor);
	
	//$('.altitudeunit').text(txt);
	var els = document.getElementsByClassName('altitudeunit');
	for(var i=els.length-1;i>=0;i--) {
		els[i].innerHTML = txt; // TODO: use nodeValue		
	}
}    



var kwd_addEvent = (function( window, document ) {
 if ( document.addEventListener ) {
  return function( elem, type, cb ) {
   if ( (elem && !elem.length) || elem === window ) {
    elem.addEventListener(type, cb, false );
   }
   else if ( elem && elem.length ) {
    var len = elem.length;
    for ( var i = 0; i < len; i++ ) {
     addEvent( elem[i], type, cb );
    }
   }
  };
 }
 else if ( document.attachEvent ) {
  return function ( elem, type, cb ) {
   if ( (elem && !elem.length) || elem === window ) {
    elem.attachEvent( 'on' + type, function() { return cb.call(elem, window.event); } );
   }
   else if ( elem.length ) {
    var len = elem.length;
    for ( var i = 0; i < len; i++ ) {
     addEvent( elem[i], type, cb );
    }
   }
 };
}
})( this, document );



/* may change in behaviour - uses click for browsermode
 * 
 */
function kwd_addTouchEvent(addid,addclass,newcallback) {
	
	var eventtype = kta.browsermode ? 'click':'touchstart';
	
	if(addid) {
		
		document.getElementById(addid).addEventListener(eventtype,newcallback);
	}
	else if(addclass){
		var els = document.getElementsByClassName(addclass);
		for(var i=els.length-1;i>=0;i--) {
			els[i].addEventListener(eventtype,newcallback);
		}
	}
	
}

/* do not check fastoptions here!! */
function kwd_setTimeFormat(evt) {
	
		settings.switchit('settimeformat');

		if (kta.clockseconds) {
			kwd_hideById('seconds-text'); //$('#seconds-text').hide();
			kta.clockseconds = false;
			showHint('Seconds off','Sekunden aus');
		}
		else {
			kwd_showById('seconds-text','inline'); //$('#seconds-text').show();
			kta.clockseconds = true;
			showHint('Seconds on','Sekunden an');
		}
}

function refreshall() {
	        // resize after init
		scaleDisplays(false);
		//ORI scaleDisplays(); // wenn später korrekt arbeitet, dürfte doppelter Aufruf egal sein!!
		positionDisplays();

}




/* vereint alle Programmstartfunktionen
(sinn siehe caller)
- returns: true: Code ausgeführt,
-          false: Code nicht ausgeführt
*/
function initApp()  {

	// TODO: here may be checks whether html not rendered ready (e.g. check a width of a certain important div)

    tablet = app.IsTablet(); // returns boolean
    

	document.getElementById('splashscreen').style.opacity = 0.1; // debug
	if (kta.version) document.getElementById('appversion').innerHTML = kta.version.toFixed(2);
    
    // ONSTART
    if(!kta.browsermode) kta.useSystemSize = true;
	
	// add the back arrows to dialogs
	var els = document.getElementsByClassName('dialog');
	for(var i = els.length-1;i>=0;i--) {
		var e = els[i];
		if((e.id != 'warningdialog') && (e.id != 'newsdialog')) {
			e.firstElementChild.insertAdjacentHTML('afterbegin','<a href="#back" class="back-arrow"><span class="icon-left-big"></span></a>'); 
		}
	} 
	
    // init gauge before first scaleDisplays!
    gauge = new CssGauge( {
		'wrapper':'cssgauge-wrapper',
		'gauge':'cssgauge',
		'size':'auto', // not yet implemented !
		'maxRange':10,
		'majorStep':1, // must be < maxRange and reasonable adjusted
		'minorTicks':2, // should be between 0 and 5
		'overallAngle':270, // degrees, better < 340
		'value':0 // must be < max Range
	});
	
	// TODO: enable again:-> add to displays list
	// for testing in browser
	if(!kta.browsermode) {
		//kwd_hideById('speedstats'); //$('#speedstats').hide();
		kwd_hideById('resetmaxspeed'); //$('#resetmaxspeed').hide();
		kwd_hideById('resetaveragespeed');//$('#resetaveragespeed').hide();
		//kwd_hideById('maxspeed'); //$('#maxspeed').hide();
		//kwd_hideById('averagespeed'); //$('#averagespeed').hide();
	}
	
	// ACHTUNG ! plastic skin deaktiviert!
	if(0 && kta.advancedstyles) {
		//$('.skin').addClass('skin-plastic');
		var skinelements = document.getElementsByClassName('skin');
		//app.Debug(skinelements.length);
		for (var i=skinelements.length-1;i>=0;i--) {
			//app.Debug(skinelements[i])
			skinelements[i].classList.add('skin-plastic');
		}		
	}
	

	analogDisplays = new AnalogSpeedBoxList(); 
 	dona = analogDisplays.add('digital-on-analog','--'); // dona must only be scaled once since it is scaled with gauge later
	dona.setFirst(true);
	
	scaleDisplays(true); // must be before all the settings-dependend turn-offs of displays (in contrast to positionDisplays)
	
	// init displays
	displays = new DisplayBoxList('geolocation');
	// save all in glob vars too
	// ! order of add must be order in HTML!
	displayTime = displays.add('time');
	displayAltitude = displays.add('geoaltitude','--');
	displayLocation = displays.add('geolocation','--');
	
	digitalSpeedDisplays = new DigitalSpeedBoxList();
	displayDigitalspeed = digitalSpeedDisplays.add('digitalspeed','--');
	displayDigitalspeed.setFirst(true);	
	
	// !! DISABLeD 
	if(kta.browsermode && 0) {
		displayAverage = displays.add('averagespeed','--');
		displayMaxspeed = displays.add('maxspeed','--');
	}
	
	// object referencing works (changes in displays.[one object] appear in references e.g. displayTime) 
	//var testobject = displays.get('time');
	//app.Debug('set new obj str: '+testobject.testString('thomas') );
	//app.Debug('check obj str in time: '+displayTime.testString() );
	
	
		    
    menustack = new KwdPopupStack();
    settings = new AutoSettings(storage_settings); // string definiert Namen in localstorage // loads saved settings
    

    gpstool = new KwdGpsTools(); //global var speed now named: gpstool
  
    // Tacho range vor möglichem 'hide' laden 
	resetTachoRange("load",10); // default==10, if no value found


    // TODO: layout_gauges sollte man evtl. auch mit einem stack steuern !!
    // TODO: oder integriert in display-objekt-verwaltung
    setTachoLayout();
	if (settings.get('tachoswitch')!=false) layout_gauges++;
	
    // this are the normal hints!
    if(settings.get('switchwarning')==false)  {
        displayHints = false;
    }
    if(settings.get('switchnews1')!=true) { // ! here: hide when true
    	menustack.push('newsdialog');
    }
    
    
    // this is the WARNING
    if(settings.get('switchredwarning')!==false)  {
    	menustack.push('warningdialog'); // note: all dialogs hidden by default!
    }
    if(settings.get('switchtime')==false) displayTime.hide(); else { layout_gauges++; startClock(); }
    if(settings.get('switchposition')==false) displayLocation.hide(); else layout_gauges++;
    if(settings.get('switchaltitude')==false) displayAltitude.hide(); else layout_gauges++;
    if(settings.get('switchhudsettings')!=false) settings.switchit('switchhudsettings'); // auto saved will be overidden here
	if (settings.get('settimeformat')==false) {
		kwd_hideById('seconds-text'); //$('#seconds-text').hide();
		kta.clockseconds = false;
	} 
            
	if (settings.get('switchfastoptions')==false) {
		kta.setFastOptions(false);
	}
	
	setLanguage(app.LoadText(kta.storage.language,'auto')); // auto bis einmal gesetzt, dann immer definiert
        
    // prevent accidently back 
    app.EnableBackKey( false ); // TODO: not until listener installed? 


    //settings.init('backkey',true); // init bewirkt, dass true nur gesetzt wird, wenn es nicht geladen werden konnte
    // init ist meist nicht nötig, wenn im html der gewünschte Anfangsstatus gesetzt ist
    
    // menu for exit instead of back a
    // TODO: what happens on tablets??
    //app.SetMenu( "Einstellungen,Beenden" );

	var units = 'setalt-m';
	if(settings.get('setalt-ft')) units = 'setalt-ft';
	setAltimeterUnits(units);
	units = 'kmh';
	if(settings.get('setmph')) units = 'mph';
	else if(settings.get('setms')) units = 'ms';
	else if(settings.get('setkn')) units = 'kn';
	setTachoUnits(units); // must be after gpstool init

    //Create and start location sensor. 
    //(Achievable update rate is hardware specific) 
    loc = app.CreateLocator( "GPS,Network" ); 
    loc.SetOnChange( loc_OnChange );  // you cannot directly set to member of gpstool :-(
    loc.SetRate( 1 ); //seconds (refresh data), test lower rate! good for background activity!
    startGps(); // never do loc.Start(); alone --> use this wrapper  
    
        
    // TODO: hier auch scaleDisplays(), besonders für Landscape
    positionDisplays();
    setGpsWarning(); // display warnings until gps receives data

    // EVENTS
	
    
    
    // if it can only be inside card, make listener there!
    kwd_addTouchEvent('','extlink',function(evt) { // TODO: check if you can deliver el (you may get it from evt)
        //var linktarget = $(this).attr("href");
        var linktarget = 'test';
        app.OpenUrl( linktarget );
        evt.preventDefault();
    });
    
    
    
    
	// adds listener to wrapper! - it works through capturing OR bubbling!
	// this is for all dialogs and settings (no info card and no display-boxes):
	// - need listener for touchstart AND touchend (otherwise you can destroy or disturb scrolling in browser )
	var wrapel = document.getElementById('touch-wrapper');
	
	// - on touchstart we save the evnt if it is interesting to us
	// - we only need to know whether the x/y has changed
	// - also could deny, if event is already under way
	// - we also color the menuitem manually if given
	// 
	 if(wrapel) wrapel.addEventListener('touchstart',function(evt) {
		
		this.kwdSwitcherId = '';
		this.kwdButtonId = '';
		this.kwdDisplayId = '';
    	this.kwdCancelTouch  = false;

		// TODO: this statt wrapel
		 
		
		// check if you can save something in this from event (x/y)
		/*var ts = evt.changedTouches;
		if(ts.length) {
			this.kwdpageX = ts[0].pageX; 
			this.kwdpageY = ts[0].pageY;
		} */
		
		// ! if there can be mor sub-spans you must check also parent of parent!
		var switcher;
		if (evt.target.classList.contains('switcher')) switcher = evt.target;
		if(!switcher && evt.target.parentNode.classList.contains('switcher')) switcher = evt.target.parentNode;
		if (switcher) {
			this.kwdSwitcherId = switcher.id;
		//	switcher.style.backgroundColor = 'rgba(255,255,255,0.3)';
		}
		else {
			// TODO: back-arrow einfach als eine button-id setzen!
			var button;
			if (evt.target.classList.contains('btn')) button = evt.target;
			if(!button && evt.target.parentNode.classList.contains('btn')) button = evt.target.parentNode;
			if (button) {
				this.kwdButtonId = button.hash;
	//			button.style.backgroundColor = '#666';
			}
			else {

				var backarrow;
				if (evt.target.classList.contains('back-arrow')) backarrow = evt.target;
				if(!backarrow && evt.target.parentNode.classList.contains('back-arrow')) backarrow = evt.target.parentNode;
				if(backarrow) {
					this.kwdButtonId = 'back-arrow';
				}
				else {
					var display = evt.target;
					var found = false;
					while (!found && display) {
						found = display.classList.contains('fast-option');
						if (!found) {
							display = display.parentElement; // == parentNode?
							if(!display || display.tagName.toLowerCase() == 'body') break;
						}
					}					
					if (display) {
						this.kwdDisplayId = display.id;
					}
				}	
			}
		}
		
		
		return true;
	});
	
	// todo: man könnte element-id bei touchstart speichern, und hier nur noch einen großen switch
	if (wrapel) wrapel.addEventListener('touchend',function(evt) {
		
		if (this.kwdCancelTouch) 
			return true;

		var dodefault = true;

/*		if(this.kwdSwitcherId) 
			document.getElementById(this.kwdSwitcherId).style.backgroundColor = 'transparent';
		/*if(this.kwdButtonId && this.kwdButtonId != 'back-arrow') {
			// Schleife über alle Buttons, da keine Button id verfügbar!!
			var els = document.getElementsByClassName('.btn');
			if (els) for(var i = els.length-1; i >= 0; i-- ) {
				if(!els[i].id || els[i].id != 'donate-button')
					els[i].style.backgroundColor = '#888';
			}
		}*/
			

		/*var ts = evt.changedTouches;
		if(ts.length) {
			//TODO: prüfe ob bereich (z.B. bis 3-5 pixel Abweichung nötig )
			if((this.kwdpageX != ts[0].pageX) || (this.kwdpageY != ts[0].pageY)) {
				this.kwdSwitcherId = this.kwdButtonId  = this.kwdDisplayId = '';
				return true; // event-Bearbeitung abgebrochen
			}
		} */

	
		// TODO: Nachdem spezielle Abfragen/Anpassungen, id für switcher/button gleichsetzen
		var check = this.kwdSwitcherId || this.kwdButtonId || this.kwdDisplayId;
		if(!check) return true;
		

		if(check) {
			// NEW: all menu items are handled here too

	    	resetMenuFade();  // TODO: nicht bei kwdDisplayId
	    	dodefault = false; // assume to find an entry *here*
	        var doPosition = false;
	        var unittext = '';
	        	        
	        switch (check) {
	        	case 'setlanguage':
			    	if (kta.language=='de') {
			    		setLanguage('en');
			    		showHint ('Touch again for German');
			    	}
			    	else {
			    		setLanguage('de');
			    		showHint ('Erneut tippen für Englisch');    		
			    	}
			    	app.SaveText(kta.storage.language,kta.language); // new val already in kta.language
			        break;
	        	case 'moresettings':
			        menustack.push('moresettingsdialog');
	        		break;
	        	case 'showinfo':
			        menustack.push('infocard');
			        break;
			    case 'tachosettings':
	    	        menustack.push('tachosettingsdialog');
	    	        break;
	    	    case 'altitudesettings':
			        menustack.push('altitudeunitsettings');
	    	        break;
	            case 'tachoswitch' :
	            	if(settings.get(check)==false) {
	            		layout_gauges ++;
	            	}      
	            	else layout_gauges --;
	                settings.switchit(check);
	                setTachoLayout();            	
	                doPosition = true;
	            	break;
	            case 'digitalanalog':     	
	            case 'digital' :
	            case 'analog' :
	            	settings.radio('radio',check);
	            	if(settings.get('tachoswitch')!=true) settings.switchit('tachoswitch'); // always activate tacho as well
	                setTachoLayout();            	
	                doPosition=true;
	                break;
	            case 'switchtime':
	                if(settings.switchit(check)) {
	                	displayTime.show();
	                	layout_gauges++ ;
	                	startClock();
	                }
	                else {
	                	displayTime.hide();
	                	layout_gauges--;
	                	stopClock();
	                }
	                doPosition = true;
	                break;
	            case 'switchaltitude':
	                
	                if(settings.switchit(check)) {
	                	displayAltitude.show();
	                	layout_gauges++ ;
	                }
	                else {
	                	displayAltitude.hide();
	                	layout_gauges--;
	                }
	                doPosition = true;
	                break;
	            case 'switchposition':
	                if(settings.switchit(check)) {
	                	displayLocation.show();
	                	layout_gauges++ ;
	                }
	                else {
	                	displayLocation.hide();
		                layout_gauges--;
	                } 
	                doPosition = true;
	                break;
	            case 'switchhudsettings':
	           		gpstool.switchHud();
	                settings.switchit(check);
	            	break;
	            case 'switchwarning':
	                if (settings.switchit(check)) {
	                    displayHints = true;
		                showHint('All notes active','Alle Hinweise aktiviert.');
	                }
	                else {
	                  showHint('All notes disabled','Alle Hinweise deaktiviert.');
					  displayHints = false;
					}  
	                
	                break;
	            case 'switchredwarning':
	                if(settings.switchit(check)) showHint('Warnings active','Warnhinweise wieder eingeschaltet.');
	                else showHint('Warnings disabled','Warnhinweise ausgeschaltet.');
	                break;                
	            case 'switchautorange':
	            	if(settings.get('tachoswitch')!=true) {
	            		settings.switchit('tachoswitch');
	            		doPosition = true;
	            	}
	            	setTachoLayout();
	                resetTachoRange("save",10);  // current minimum
	                showHint('Speedometer auto range reset','Auto-Bereich zurückgesetzt');
	                break;
	            case 'switchunits':
	            	menustack.push('unitsettings');
					break;
	            case 'setkmh': unittext = 'kmh'; break;      	
	            case 'setmph': unittext = 'mph'; break;    	
	            case 'setms':  unittext = 'ms'; break;   	
	            case 'setkn':  unittext = 'kn'; break;   	
	            case 'switchfastoptions':
	            	settings.switchit(check);
         			kta.setFastOptions(!kta.fastoptions); // = toggle
	            	break;
	            case 'dona-tachounit':
	            case 'kmh-digital':
					if (kta.fastoptions) {
						var newunit = 'kmh';
						if(settings.get('setkmh')) newunit = 'mph';
						if(settings.get('setmph')) newunit = 'kn';
						if(settings.get('setkn')) newunit = 'ms';
						setTachoUnits(newunit);
						settings.radio('unitradio','set'+newunit);
					}
					else dodefault = true;					
	            	break;
	            	
				case 'tacho-container' :
			    	if(kta.fastoptions && settings.get('tachoswitch')!=false) {
			    		var next;
			    		if (settings.get('digitalanalog')!=false) next = 'digital';
			    		else if (settings.get('digital')!=false) next = 'analog';
			    		else next = 'digitalanalog';
			    			
				       	settings.radio('radio',next);
				        setTachoLayout();            	
				        doPosition = true;
				        switch(next) {
				        	case 'digitalanalog':showHint('Touch again for Digital display','Erneut Tippen für Digital'); break;
				        	case 'digital': showHint('Touch again for Analog display','Erneut Tippen für Analog'); break;
				        	case 'analog': showHint('Touch again for both displays','Erneut Tippen für Digital + Analog'); break;
				        }
			    	} else dodefault = true;
			    	
			    	break; 
	            	
	            	
	            case 'm-alt':
	            	if (kta.fastoptions) {
						if(settings.get('setalt-ft')) check = 'setalt-m'; // TODO: getter of set element of a radio group
		            	else check = 'setalt-ft';
		            }
		            else {
		            	dodefault = true;
		            	break; // break nur im else und nicht unten!
		            }
	            case 'setalt-ft':
	            case 'setalt-m':
	            	settings.radio('altunits',check);
	            	setAltimeterUnits(check);
	            	//OnBack();
	            	break;
				case 'time':
				case 'settimeformat':
					kwd_setTimeFormat();
					break;
				case 'geolocation':
				    if(kta.fastoptions) {    		
				        if(gpstool.switchLocFormat()=='decimal') 
				        	showHint('Touch again for degree values','Tippen für Grad-Anzeige');
				        else showHint('Touch again for decimal values','Tippen für Dezimal-Anzeige');
			    	}
    				break;
	            case 'switchnews1':
	            	settings.switchit(check);
	            	break;
	            	
	            case 'resetmaxspeed':
					menustack.push('askresetmaxspeed',true); // TODO: error when second param not yet used?
					break;

				// .btn
				
	            case '#exit' : Quit(); break;
	            case '#cancel' : OnBack(); break; // TODO: test
	            case '#settings' : OnMenu(); break; // TODO: check if can be started inside menus!! (Hope menus ly over :-)
	            case '#info' :
	                menustack.push('infocard');
	                //app.ShowDebug(false);
	                break;
				case '#warningcont' :
					// TODO: check if another menu COULD come in between!
					OnBack();
					break;
				case '#confirmresetmaxspeed' : 				
					gpstool.maxSpeed(-1); // neg. value forces set, default 1, because -0 is just 0
					showHint('Maximum speed reset','Höchstgeschwindigkeit zurückgesetzt');
					OnBack();
					break;				
				case '#confirmresetaveragespeed' : 				
					gpstool.maxSpeed(-1); // neg. value forces set, default 1, because -0 is just 0
					showHint('Maximum speed reset','Höchstgeschwindigkeit zurückgesetzt');
					OnBack();
					break;
					
					
				case 'back-arrow':
					OnBack();
					break;					

	            default: dodefault = true;
	            break;
	        }
	
	        if (unittext) {
	        	// TODO: eleganter: set von 'check' abschneiden und Aufruf (siehe setAltimeterUnits())
	        	settings.radio('unitradio',check);
	        	setTachoUnits(unittext);
	        	//OnBack(); // proceed like Android select menu
	        }
	        else if(doPosition) positionDisplays();
	
	        // always (cases are checked inside functions)
			startGps();        
		} // end of switchers + buttons
		
		this.kwdSwitcherId = this.kwdButtonId  = this.kwdDisplayId = '';
		
		if(!dodefault) {
			evt.stopPropagation();
			evt.preventDefault();
			return false;
		}
		return true;
	}); 
    
    if(wrapel) wrapel.addEventListener('touchmove',function(evt) {
    	
		this.kwdSwitcherId = this.kwdButtonId  = this.kwdDisplayId = '';
    	this.kwdCancelTouch  = true;
      	return true;
    });
    


    // findet alle ext-link, wenn bubble
    document.getElementById('infocard').addEventListener('click',function(evt) { // bewusst hier click!
		
		var e = evt.target;
		var found = false;
		while (!found && e) {
			found = e.classList.contains('ext-link');
			if (!found) {
				e = e.parentElement; // == parentNode?
				if(!e || e.tagName.toLowerCase() == 'body') break;
			}
		}					
		
		if (e) {
			var lhash = e.hash; // hoffentlich hash nicht undefined
			if(lhash && lhash == '#back') OnBack();
			else {
		        var linktarget = e.href;
		        app.OpenUrl( linktarget );
		        evt.preventDefault();
		        evt.stopPropagation();
		        return false;
			} 
		}
		
		return true;    	
    });
    
   	var els = document.getElementsByClassName('card');
   	for(var i=els.length-1;i>=0;i--) {
	   	kwd_addEvent(els[i],'scroll',function() {
   			resetMenuFade();
   		});
   	}
   	
   	
   	
   	//TODO: check if works!!!
	kwd_addEvent( window, 'scroll', function() {
		resetMenuFade();
	});

	var TO = false;

	kwd_addEvent(window, 'resize', function() {

        // TODO: only if really needed: 
        //      handle problem with possible multiple trigger resize events in some cases
        // see  tangara
        
        // TODO: warum reagiert nicht, wenn Statusbar des Gerätes weg ??
        // TODO: teste ob OnConfig bei Statusbar-weg reagiert !
        if(!kta.resizes) kta.resizes = 1;
        app.Debug("window resize #"+kta.resizes);
        kta.resizes++;

		 if(TO !== false) clearTimeout(TO);
		 TO = setTimeout(refreshall, 100);
    });
    
    
    //$('#splashscreen').hide();
    document.getElementById('splashscreen').style.display = 'none';
    
    app.Debug('num gauges:'+layout_gauges);
    resetHud();
    resetMenuFade();

} // initApp


function OnStart() {
	//app.SetDebugEnabled( false ); // check if app.Debug calls cause error (use wrapper function!)
	//mydebug = app.CreateDebug();
	//app.ShowDebug(true);
	
	app.Debug("onStart");
    //app.SetScreenMode( "Full"); // TODO: probleme mit Schriftgrößen und Tap-Events 
    app.PreventScreenLock(true);

	if (app.kwd_droidscript_emulator) {
		kta.browsermode = true;
		app.Debug('browser mode');
	} 
	else app.Debug('droidscript mode');
	
	if(app.GetOSVersion()>=14) { // 14 == Android 4.0.1
		kta.advancedstyles = true;
		app.Debug('modern Android version found');
	}
	if(typeof document.getElementsByTagName != 'undefined' && typeof document.getElementsByClassName  != 'undefined') {		
		kta.nojquery = true; // TODO: better ask the functions you need e.g. getElementsByClassname
		app.Debug('modern javascript found');
		//kwd_setElementText('#internalinfo','(x)');
	}
			
	// force portrait until layout is more flexible:
	//app.SetOrientation( "Portrait" ); 
	// für lock -> bekommt man halt entweder primary portrait oder primary landscape
        	
	setTimeout(initApp,100);
}


/*
 TODO: just for RESIZE event 
 $(document).ready(function() {

	app.Debug('document ready');
	
	 // more reliable than onconfig ! :-)
	 $(window).resize(function() {

	 	var rc; // check if closure works
	 	
	 	if (typeof rc == 'undefined') rc = 0;
	 	else rc++;
        // TODO: only if really needed: 
        //      handle problem with possible multiple trigger resize events in some cases
        
        // TODO: warum reagiert nicht, wenn Statusbar des Gerätes weg ??
        // TODO: teste ob OnConfig bei Statusbar-weg reagiert !
        app.Debug("window resize "+rc);
        
		if (initApp()==false) {
            // resize after init
    		scaleDisplays(false);
    		//ORI scaleDisplays(); // wenn später korrekt arbeitet, dürfte doppelter Aufruf egal sein!!
    		positionDisplays();
		}
    });
    
});
*/

// verwende source id : de.kuehne_webdienste.kwdtacho
	
</script>   
</body>
</html> 